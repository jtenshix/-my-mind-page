 <!DOCTYPE html>
<html lang="es">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
Â  <title>Notas OceÃ¡nicas - Polaroid</title>
Â  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-app-compat.js"></script>
Â  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-firestore-compat.js"></script>
Â  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@8.3.0/dist/gridstack.min.css" />
Â  <script src="https://cdn.jsdelivr.net/npm/gridstack@8.3.0/dist/gridstack-all.js"></script>
Â <style>
/* REEMPLAZA tus reglas originales de arrastre por ESTE BLOQUE */
/* Estilo para arrastrar IMAGEN y su contenido */
.grid-stack-item[data-note-type="imagen"].grid-stack-item-dragging,
.grid-stack-item[data-note-type="imagen"].grid-stack-item-dragging .grid-stack-item-content { /* Aplica tambiÃ©n al contenido */
Â  opacity: 0.7 !important;
Â  border: 3px dashed red !important;
Â  background-color: rgba(255, 0, 0, 0.3) !important;
Â  box-shadow: none !important; /* Quita sombra */
}
/* Estilo para arrastrar TEXTO y su contenido */
.grid-stack-item[data-note-type="texto"].grid-stack-item-dragging,
.grid-stack-item[data-note-type="texto"].grid-stack-item-dragging .grid-stack-item-content { /* Aplica tambiÃ©n al contenido */
Â  opacity: 0.7 !important;
Â  border: 3px dashed #a2dff7 !important;
Â  background-color: rgba(162, 223, 247, 0.3) !important;
Â  box-shadow: none !important; /* Quita sombra */
}
/* Las reglas siguientes (placeholder, html/body, etc.) dÃ©jalas como estÃ¡n */
/* Ocultar el placeholder de GridStack */
.grid-stack-placeholder {
Â  display: none !important;
}
/* Estilos CSS base y layout */
html,
body {
Â  margin: 0;
Â  padding: 0;
Â  height: 100vh;
Â  overflow: hidden;
Â  background: linear-gradient(to bottom, #a2dff7 0%, #a2dff7 40%, #03254c 100%);
Â  font-family: Arial, sans-serif;
}
.container {
Â  height: 100%;
Â  width: 100%;
Â  display: flex;
Â  flex-direction: column;
Â  position: relative;
Â  overflow: hidden;
}
#notaDisplay {
Â  flex-grow: 1;
Â  width: 100%;
Â  overflow-y: auto;
Â  overflow-x: hidden;
Â  position: relative;
Â  min-width: 1000px;
}
.grid-stack-item {
Â  transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
Â  overflow: visible !important;
Â  margin-bottom: 0px; /* Espacio adicional debajo de cada nota */
}
.grid-stack-item-content {
Â  overflow: visible !important;
Â  height: auto;
Â  width: 100%;
Â  display: flex;
Â  flex-direction: column;
}

.card-wrapper,
.text-card {
Â  background-color: #fff;
Â  border: 2px solid #0077a3;
Â  border-radius: 8px;
Â  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
Â  /* Eliminado width/height fijo */
Â  display: flex;
Â  flex-direction: column;
Â  position: relative;
Â  box-sizing: border-box;
}
.image-container {
Â  width: 100%;
Â  height: 100%; /* Cambiado a 100% para que se ajuste a GridStack item */
Â  overflow: hidden;
Â  position: relative;
Â  flex-shrink: 0;
}

.image-container img {
Â  width: 100%;
Â  height: 100%;
Â  object-fit: cover;
Â  display: block;
}


.note-content {
Â  background-color: #fff;
Â  padding: 10px;
Â  text-align: left;
Â  font-size: 16px;
Â  color: #333;
Â  min-height: 50px;
Â  box-sizing: border-box;
Â  word-wrap: break-word;
Â  overflow: hidden;
Â  flex-grow: 1;
}

.note-content a {
Â  color: #0077a3;
Â  text-decoration: underline;
}

.menu-bar {
Â  background-color: #0288D1;
Â  padding: 5px 8px;
Â  display: flex;
Â  justify-content: space-between;
Â  align-items: center;
Â  flex-shrink: 0;
Â  border-top: 1px solid #0077a3;
Â  border-bottom-left-radius: 6px;
Â  border-bottom-right-radius: 6px;
}

.menu-icon {
Â  background: none;
Â  border: none;
Â  font-size: 20px;
Â  color: #fff;
Â  cursor: pointer;
Â  padding: 2px 4px;
}
.bubble-icon {
Â  color: #FFCD05;
Â  font-size: 22px;
}

.menu-actions {
Â  display: flex;
Â  gap: 4px;
}
#addNoteButton {
Â  position: absolute;
Â  bottom: 30px;
Â  right: 30px;
Â  background-color:#006994;
Â  color:#fff;
Â  border: none;
Â  border-radius: 50%;
Â  width: 60px;
Â  height: 60px;
Â  font-size: 30px;
Â  display: flex;
Â  justify-content: center;
Â  align-items: center;
Â  cursor: pointer;
Â  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
Â  transition: background-color 0.3s ease, transform 0.3s ease;
Â  z-index: 1001;
}
#addNoteButton:hover {
Â  background-color: #005577;
Â  transform: scale(1.05);
}
#addNoteOptions {
Â  position: fixed;
Â  top: 50%;
Â  left: 50%;
Â  transform: translate(-50%, -50%);
Â  background-color: rgba(0, 0, 0, 0.85);
Â  border-radius: 10px;
Â  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
Â  display: none;
Â  flex-direction: row;
Â  justify-content: center;
Â  align-items: center;
Â  gap: 25px;
Â  padding: 25px;
Â  z-index: 1002;
}
#addNoteOptions .card {
Â  background-color: #2c2c2c;
Â  border: 1px solid #0077a3;
Â  border-radius: 8px;
Â  padding: 20px;
Â  text-align: center;
Â  cursor: pointer;
Â  transition: transform 0.2s ease, box-shadow 0.2s ease;
Â  width: 180px;
}

#addNoteOptions .card:hover {
Â  transform: translateY(-5px) scale(1.03);
Â  box-shadow: 0 6px 12px rgba(0, 119, 163, 0.5);
}

#addNoteOptions .card h2 {
Â  color: #36a2eb;
Â  margin-bottom: 10px;
}
#addNoteOptions .card p {
Â  color: #ccc;
Â  font-size: 14px;
}
#inputArea {
Â  position: fixed;
Â  top: 50%;
Â  left: 50%;
Â  transform: translate(-50%, -50%);
Â  background-color: #ffffff;
Â  padding: 25px 30px;
Â  border-radius: 8px;
Â  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
Â  display: none;
Â  flex-direction: column;
Â  gap: 15px;
Â  width: 90%;
Â  max-width: 550px;
Â  z-index: 1002;

}



#inputArea label {

Â  font-weight: bold;

Â  color: #333;

Â  margin-bottom: 3px;

Â  font-size: 14px;

}



#inputArea textarea,

#inputArea input[type="text"] {

Â  padding: 12px;

Â  border: 1px solid #ccc;

Â  border-radius: 4px;

Â  resize: vertical;

Â  width: 100%;

Â  box-sizing: border-box;

Â  line-height: 1.5;

Â  font-size: 16px;

}



#inputArea textarea {

Â  min-height: 80px;

}



#inputArea textarea#textNote {

Â  min-height: 120px;

}



#inputArea button {

Â  padding: 10px 20px;

Â  background-color: #006994;

Â  color: #fff;

Â  border: none;

Â  border-radius: 4px;

Â  cursor: pointer;

Â  transition: background-color 0.3s ease, transform 0.1s ease;

Â  align-self: flex-end;

Â  margin-top: 10px;

Â  font-size: 16px;

Â  font-weight: bold;

}



#inputArea button:hover {

Â  background-color: #005577;

}



#inputArea button:active {

Â  transform: scale(0.98);

}



.input-group {

Â  display: flex;

Â  flex-direction: column;

Â  gap: 5px;

}



.calendar-icon {

Â  position: absolute;

Â  bottom: 30px;

Â  left: 30px;

Â  width: 45px;

Â  height: 45px;

Â  background-color: #fff;

Â  border: 1px solid #ccc;

Â  border-radius: 50%;

Â  display: flex;

Â  justify-content: center;

Â  align-items: center;

Â  color: #333;

Â  font-size: 24px;

Â  cursor: pointer;

Â  z-index: 1001;

Â  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);

}



.calendar-widget {

Â  position: absolute;

Â  bottom: 85px;

Â  left: 20px;

Â  background: #fff;

Â  border: 1px solid #ddd;

Â  border-radius: 6px;

Â  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);

Â  padding: 15px;

Â  display: none;

Â  z-index: 1001;

Â  width: 320px;

Â  min-height: 300px;

}



.calendar-header {

Â  display: flex;

Â  justify-content: space-between;

Â  align-items: center;

Â  margin-bottom: 15px;

}



.calendar-header button {

Â  background: none;

Â  border: none;

Â  cursor: pointer;

Â  font-size: 20px;

Â  color: #0077a3;

Â  padding: 5px 8px;

Â  border-radius: 4px;

Â  transition: background-color 0.2s ease;

}



.calendar-header button:hover:not(:disabled) {

Â  background-color: #e0f7fa;

}



.calendar-header button:disabled {

Â  color: #ccc;

Â  cursor: default;

}



.calendar-header span {

Â  font-weight: bold;

Â  color: #333;

Â  font-size: 18px;

}



.calendar-days-header,

.calendar-dates-grid {

Â  display: grid;

Â  grid-template-columns: repeat(7, 1fr);

Â  text-align: center;

Â  gap: 6px;

}



.calendar-days-header {

Â  margin-bottom: 10px;

Â  font-weight: bold;

Â  color: #555;

Â  padding-bottom: 8px;

Â  border-bottom: 1px solid #eee;

Â  font-size: 13px;

}



.calendar-day {

Â  padding: 3px;

}



.calendar-date {

Â  padding: 0;

Â  border-radius: 50%;

Â  color: #333;

Â  border: 2px solid transparent;

Â  cursor: pointer;

Â  position: relative;

Â  width: 36px;

Â  height: 36px;

Â  display: flex;

Â  align-items: center;

Â  justify-content: center;

Â  margin: 0 auto;

Â  line-height: 1;

Â  font-size: 14px;

Â  transition: background-color 0.2s ease, border-color 0.2s ease;

}



.calendar-date.empty {

Â  background: none;

Â  cursor: default;

Â  opacity: 0;

}



.calendar-date:not(.empty):hover {

Â  background-color: #e0f7fa;

Â  border-color: #b3e5fc;

}



.calendar-date.today {

Â  border-color: #0077a3;

Â  font-weight: bold;

Â  color: #005577;

}



.calendar-date.drag-over {

Â  background-color: #a2dff7 !important;

Â  border-color: #0077a3 !important;

}



.assigned-bubble {

Â  color: #FFCD05;

Â  font-size: 11px;

Â  position: absolute;

Â  bottom: 3px;

Â  left: 50%;

Â  transform: translateX(-50%);

Â  line-height: 1;

Â  text-shadow: 0 0 1px rgba(0, 0, 0, 0.5);

Â  pointer-events: none;

}



.calendar-date .assigned-bubble+.assigned-bubble {

Â  bottom: -2px;

}



.blur-background {

Â  position: fixed;

Â  top: 0;

Â  left: 0;

Â  width: 100%;

Â  height: 100%;

Â  background: rgba(0, 0, 0, 0.6);

Â  backdrop-filter: blur(6px);

Â  -webkit-backdrop-filter: blur(6px);

Â  display: none;

Â  z-index: 1000;

Â  cursor: pointer;

}

Â  Â /* Responsive GridStack Columns */

@media (max-width: 575.98px) {

Â  Â  /* MÃ³vil: 3 Columnas (handled by JS) */

}

@media (min-width: 576px) and (max-width: 991.98px) {

Â  Â  /* Tablet: 6 Columnas (handled by JS) */

}

/* Default is 12 columns */



/* Optional: Ajustes bÃ¡sicos para modales/botones en mÃ³vil */

@media (max-width: 575.98px) {

Â  Â  #inputArea { width: 95%; }

Â  Â  #addNoteOptions { flex-direction: column; gap: 15px; padding: 20px; }

Â  Â  #addNoteOptions .card { width: 150px; }

}

</style>

</head>



<body>

Â  <div class="container">

Â  Â  <div id="notaDisplay" class="grid-stack"></div>

Â  Â  <button id="addNoteButton" title="AÃ±adir nueva nota o imagen">+</button>

Â  Â  <div id="addNoteOptions">

Â  Â  Â  <div class="card" id="addImageLinkOption" title="AÃ±adir una nota con imagen desde un enlace web">

Â  Â  Â  Â  <h2>ğŸ–¼ï¸ Imagen</h2>

Â  Â  Â  Â  <p>Guardar link de imagen.</p>

Â  Â  Â  </div>

Â  Â  Â  <div class="card" id="addTextNoteOption" title="AÃ±adir una nota de texto simple">

Â  Â  Â  Â  <h2>ğŸ“ Nota</h2>

Â  Â  Â  Â  <p>Subir nota de texto.</p>

Â  Â  Â  </div>

Â  Â  </div>

Â  Â  <div id="inputArea">

Â  Â  Â  <div id="imageLinkInputArea" style="display: none;">

Â  Â  Â  Â  <div class="input-group">

Â  Â  Â  Â  Â  <label for="imageLink">Link de la imagen:</label>

Â  Â  Â  Â  Â  <input type="text" id="imageLink" placeholder="Pega aquÃ­ la URL de la imagen (ej: https://...)" />

Â  Â  Â  Â  </div>

Â  Â  Â  Â  <div class="input-group">

Â  Â  Â  Â  Â  <label for="imageNoteText">Texto adicional (opcional):</label>

Â  Â  Â  Â  Â  <textarea id="imageNoteText" placeholder="Escribe aquÃ­ una descripciÃ³n o nota relacionada con la imagen..." rows="3"></textarea>

Â  Â  Â  Â  </div>

Â  Â  Â  Â  <button id="saveImageLink">Guardar Imagen</button>

Â  Â  Â  </div>

Â  Â  Â  <div id="textNoteInputArea" style="display: none;">

Â  Â  Â  Â  <div class="input-group">

Â  Â  Â  Â  Â  <label for="textNote">Nota:</label>

Â  Â  Â  Â  Â  <textarea id="textNote" placeholder="Escribe tu nota aquÃ­..." rows="5"></textarea>

Â  Â  Â  Â  </div>

Â  Â  Â  Â  <button id="saveTextNote">Guardar Nota</button>

Â  Â  Â  </div>

Â  Â  </div>

Â  Â  <div id="calendarIcon" class="calendar-icon" title="Mostrar/Ocultar Calendario">ğŸ“…</div>

Â  Â  <div id="calendarWidget" class="calendar-widget"></div>

Â  Â  <div class="blur-background"></div>

Â  </div>

Â  <script>

Â  Â  /****************** Utilidades y ConfiguraciÃ³n de Firebase ******************/

Â  Â  function linkify(text) {

Â  Â  Â  if (!text) return "";

Â  Â  Â  const urlRegex = /(?<!href=["'])(https?:\/\/[^\s<>"']+)/g;

Â  Â  Â  const replacedText = text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');

Â  Â  Â  return replacedText.replace(/\n/g, '<br>');

Â  Â  }

Â  Â  const firebaseConfig = {

Â  Â  Â  apiKey: "AIzaSyCHa373WgLLHsy8wZXK9zr_HVieQvlrhUs",

Â  Â  Â  authDomain: "oasis-b036d.firebaseapp.com",

Â  Â  Â  projectId: "oasis-b036d",

Â  Â  Â  storageBucket: "oasis-b036d.appspot.com",

Â  Â  Â  messagingSenderId: "141546637821",

Â  Â  Â  appId: "1:141546637821:web:0a861aeb13831774ed3194",

Â  Â  Â  measurementId: "G-HB2P17H5YL"

Â  Â  };

Â  Â  try {

Â  Â  Â  firebase.initializeApp(firebaseConfig);

Â  Â  } catch (e) {

Â  Â  Â  console.error("Error inicializando Firebase:", e);

Â  Â  }

Â  Â  const db = firebase.firestore();

Â  Â  /****************** InicializaciÃ³n de GridStack ******************/

Â  Â  let grid;

Â  Â  try {

Â  Â  Â  grid = GridStack.init({

Â  Â  Â  Â  column: 12, // Permitir movimiento horizontal

Â  Â  Â  Â  margin: 10, // Margen entre elementos

Â  Â  Â  Â  cellHeight: 'auto', // Altura de cada celda

Â  Â  Â  Â  disableResize: true, // Deshabilitar redimensionamiento

Â  Â  Â  Â  float: true,

Â  Â  Â  Â  overlap: false,

Â  Â  Â  Â  animate: true,

Â  Â  Â  Â  alwaysShowResizeHandle: false,

Â  Â  Â  Â  draggable: {

Â  Â  Â  Â  Â  handle: '.menu-bar',

Â  Â  Â  Â  Â  scroll: true,

Â  Â  Â  Â  Â  appendTo: 'body'

Â  Â  Â  Â  }

Â  Â  Â  });

Â  Â  } catch (e) {

Â  Â  Â  console.error("Error inicializando GridStack:", e);

Â  Â  Â  alert("Error al iniciar el Ã¡rea de notas.");

Â  Â  }

Â  Â  // LÃ³gica JS para ajustar columnas de GridStack con el tamaÃ±o de la pantalla



const gridStackElement = document.getElementById('notaDisplay');

let currentColumnCount = 12;



const breakpoints = [

Â  Â  { width: 992, cols: 12 },

Â  Â  { width: 576, cols: 6 },

Â  Â  { width: 0, cols: 3 }

];



function adjustGridColumns() {

Â  Â  const screenWidth = window.innerWidth;

Â  Â  let newColumnCount = 12;



Â  Â  for (const bp of breakpoints) {

Â  Â  Â  Â  if (screenWidth >= bp.width) {

Â  Â  Â  Â  Â  Â  newColumnCount = bp.cols;

Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  }

Â  Â  }



Â  Â  if (newColumnCount !== currentColumnCount) {

Â  Â  Â  Â  if (grid) {

Â  Â  Â  Â  Â  Â  Â grid.column(newColumnCount, true); // Ajusta columnas

Â  Â  Â  Â  }

Â  Â  Â  Â  currentColumnCount = newColumnCount;

Â  Â  }

}



adjustGridColumns(); // Ejecutar al cargar

let resizeTimer;

window.addEventListener('resize', () => {

Â  Â  clearTimeout(resizeTimer);

Â  Â  resizeTimer = setTimeout(adjustGridColumns, 100); // Ejecutar al redimensionar

});



// --- Fin LÃ³gica JS Responsiva ---

Â  Â  /****************** Escucha de Cambios en GridStack (Drag/Drop) ******************/

Â  Â  if (grid) { // AsegÃºrate que grid se inicializÃ³ bien

Â  Â  Â  // Listener para el evento 'change' (cuando algo cambia en el grid, INCLUYENDO drag/drop)

Â  Â  Â  grid.on('change', function (event, items) {

Â  Â  Â  Â  console.log("Evento 'change' de GridStack disparado.");

Â  Â  Â  Â  items.forEach(function (item) {

Â  Â  Â  Â  Â  // Intentamos obtener el ID de la nota del atributo data-note-id

Â  Â  Â  Â  Â  const noteId = item.el?.getAttribute('data-note-id') || item.id || '(desconocido)';

Â  Â  Â  Â  Â  console.log(` - Nota ID: ${noteId}, PosiciÃ³n final segÃºn GridStack: x=${item.x}, y=${item.y}, w=${item.w}, h=${item.h}`);

Â  Â  Â  Â  Â  // IMPORTANTE: AquÃ­ es donde deberÃ­amos guardar la posiciÃ³n final en Firestore

Â  Â  Â  Â  Â  // si GridStack es quien decide la posiciÃ³n final despuÃ©s de un drag/drop.

Â  Â  Â  Â  Â  const noteIdToSave = item.el?.getAttribute('data-note-id');

Â  Â  Â  Â  Â  // Guardamos si tenemos datos vÃ¡lidos. PodrÃ­amos necesitar mÃ¡s lÃ³gica para evitar guardar

Â  Â  Â  Â  Â  // en cambios que no son de drag/drop si eso causa problemas.

Â  Â  Â  Â  Â  if (noteIdToSave && typeof item.x === 'number' && typeof item.y === 'number') {

Â  Â  Â  Â  Â  Â  console.log(`Â  Â (Considerando guardar x:${item.x}, y:${item.y} para ${noteIdToSave} en Firestore desde 'change')`);

Â  Â  Â  Â  Â  Â  // DESCOMENTA la lÃ­nea de abajo para activar el guardado automÃ¡tico desde aquÃ­ (QUITANDO // ):

Â  Â  Â  Â  Â  Â  db.collection('notas').doc(noteIdToSave).update({

Â  Â  Â  Â  Â  Â  Â  x: item.x,

Â  Â  Â  Â  Â  Â  Â  y: item.y

Â  Â  Â  Â  Â  Â  }).catch(err => console.error(`Error guardando posiciÃ³n desde 'change': ${err}`));

Â  Â  Â  Â  Â  }

Â  Â  Â  Â  });

Â  Â  Â  });

Â  Â  Â  // Listener para 'dragstop' (solo para ver dÃ³nde se suelta inicialmente)

Â  Â  Â  grid.on('dragstop', function (event, element) {

Â  Â  Â  Â  const node = grid.engine.nodes.find(n => n.el === element); //

Â  Â  Â  Â  if (node) {

Â  Â  Â  Â  Â  const noteId = node.el?.getAttribute('data-note-id') || node.id || '(desconocido)';

Â  Â  Â  Â  Â  console.log(`Evento 'dragstop': Nota ID: ${noteId} soltada en x=${node.x}, y=${node.y}`);

Â  Â  Â  Â  }

Â  Â  Â  });

Â  Â  Â  // LÃ­nea de verificaciÃ³n para saber si estos listeners se aÃ±adieron

Â  Â  Â  console.log(">>> LISTENER ATTACHED TO GRID <<<");

Â  Â  } // Fin del if (grid)

Â  Â  /****************** Utilidades UI (Scroll, Resize Textarea) ******************/

Â  Â  const gridContainer = document.getElementById('notaDisplay');

Â  Â  if (gridContainer) gridContainer.addEventListener('wheel', (event) => {}, { passive: true });

Â  Â  function autoResizeTextarea(el) { if (!el) return; el.style.height = 'auto'; el.style.height = (el.scrollHeight + 2) + 'px'; }

Â  Â  const textNoteInputElem = document.getElementById('textNote');

Â  Â  const imageNoteTextElem = document.getElementById('imageNoteText');

Â  Â  if (textNoteInputElem) textNoteInputElem.addEventListener('input', () => autoResizeTextarea(textNoteInputElem));

Â  Â  if (imageNoteTextElem) imageNoteTextElem.addEventListener('input', () => autoResizeTextarea(imageNoteTextElem));

Â  Â  /****************** RenderizaciÃ³n, EdiciÃ³n y EliminaciÃ³n de Notas ******************/

Â  Â  const displayedNotes = new Map();

Â  Â  // --- FUNCIÃ“N PARA MOSTRAR NOTA ---

Â  Â  function mostrarNotaEnPantalla(doc) {

Â  Â  Â  const notaData = doc.data();

Â  Â  Â  const noteId = doc.id;

Â  Â  Â  let gridItem = document.createElement('div');

Â  Â  Â  gridItem.classList.add('grid-stack-item');

Â  Â  Â  gridItem.setAttribute('data-note-id', noteId);

Â  Â  Â  gridItem.setAttribute('data-note-type', notaData.tipo); //

Â  Â  Â  const content = document.createElement('div');

Â  Â  Â  content.classList.add('grid-stack-item-content');

Â  Â  Â  let card;

Â  Â  Â  let noteContentElement;

Â  Â  Â  if (notaData.url) { // Tarjeta Imagen

Â  Â  Â  Â  card = document.createElement('div');

Â  Â  Â  Â  card.classList.add('card-wrapper');

Â  Â  Â  Â  const imageContainer = document.createElement('div');

Â  Â  Â  Â  imageContainer.classList.add('image-container');

Â  Â  Â  Â  const img = document.createElement('img');

Â  Â  Â  Â  img.src = notaData.url;

Â  Â  Â  Â  img.alt = notaData.texto || 'Imagen de la nota';

Â  Â  Â  Â  img.loading = 'lazy';

Â  Â  Â  Â  img.onerror = () => { imageContainer.innerHTML = `<div style="display:flex; align-items:center; justify-content:center; height:100%; background-color:#eee; color:red; text-align:center; padding:10px;">âš ï¸<br/>Error al<br/>cargar imagen</div>`; }

Â  Â  Â  Â  imageContainer.appendChild(img);

Â  Â  Â  Â  card.appendChild(imageContainer);

Â  Â  Â  Â  if (notaData.texto) {

Â  Â  Â  Â  Â  noteContentElement = document.createElement('div');

Â  Â  Â  Â  Â  noteContentElement.classList.add('note-content');

Â  Â  Â  Â  Â  noteContentElement.innerHTML = linkify(notaData.texto);

Â  Â  Â  Â  Â  card.appendChild(noteContentElement);

Â  Â  Â  Â  }

Â  Â  Â  } else if (notaData.nota) { // Tarjeta Texto

Â  Â  Â  Â  card = document.createElement('div');

Â  Â  Â  Â  card.classList.add('text-card');

Â  Â  Â  Â  noteContentElement = document.createElement('div');

Â  Â  Â  Â  noteContentElement.classList.add('note-content');

Â  Â  Â  Â  noteContentElement.innerHTML = linkify(notaData.nota);

Â  Â  Â  Â  card.appendChild(noteContentElement);

Â  Â  Â  } else {

Â  Â  Â  Â  return null;

Â  Â  Â  } // Nota vacÃ­a

Â  Â  Â  if (noteContentElement) {

Â  Â  Â  Â  Array.from(noteContentElement.getElementsByTagName('a')).forEach(link => {

Â  Â  Â  Â  Â  link.setAttribute('target', '_blank');

Â  Â  Â  Â  Â  link.setAttribute('rel', 'noopener noreferrer');

Â  Â  Â  Â  });

Â  Â  Â  }

Â  Â  Â  // Barra de MenÃº

Â  Â  Â  const menuBar = document.createElement('div');

Â  Â  Â  menuBar.classList.add('menu-bar');

Â  Â  Â  const bubbleButton = document.createElement('button');

Â  Â  Â  bubbleButton.classList.add('menu-icon', 'bubble-icon');

Â  Â  Â  bubbleButton.innerHTML = 'â—';

Â  Â  Â  bubbleButton.setAttribute('draggable', 'true');

Â  Â  Â  bubbleButton.id = `bubble-${noteId}`;

Â  Â  Â  bubbleButton.title = "Arrastrar al calendario";

Â  Â  Â  bubbleButton.style.display = notaData.assignedDate ? 'none' : 'inline-block';

Â  Â  Â  bubbleButton.addEventListener('dragstart', (e) => {

Â  Â  Â  Â  var imgGhost = new Image();

Â  Â  Â  Â  imgGhost.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';

Â  Â  Â  Â  e.dataTransfer.setDragImage(imgGhost, 0, 0);

Â  Â  Â  Â  e.dataTransfer.setData("application/note-id", noteId);

Â  Â  Â  Â  e.dataTransfer.effectAllowed = "move";

Â  Â  Â  Â  openCalendar();

Â  Â  Â  });

Â  Â  Â  bubbleButton.addEventListener('click', (e) => {

Â  Â  Â  Â  e.stopPropagation();

Â  Â  Â  Â  openCalendar();

Â  Â  Â  });

Â  Â  Â  const menuActions = document.createElement('div');

Â  Â  Â  menuActions.classList.add('menu-actions');

Â  Â  Â  const editButton = document.createElement('button');

Â  Â  Â  editButton.classList.add('menu-icon');

Â  Â  Â  editButton.innerHTML = 'âœ';

Â  Â  Â  editButton.title = "Editar";

Â  Â  Â  const deleteButton = document.createElement('button');

Â  Â  Â  deleteButton.classList.add('menu-icon');

Â  Â  Â  deleteButton.innerHTML = 'âœ–';

Â  Â  Â  deleteButton.title = "Eliminar";

Â  Â  Â  // onclick de deleteButton (SIN confirmaciÃ³n)

Â  Â  Â  deleteButton.onclick = (e) => {

Â  Â  Â  Â  e.stopPropagation();

Â  Â  Â  Â  if (typeof deleteNote === 'function') deleteNote(noteId, gridItem);

Â  Â  Â  Â  else {

Â  Â  Â  Â  Â  console.error("FunciÃ³n deleteNote no encontrada");

Â  Â  Â  Â  Â  alert("Error interno al eliminar.");

Â  Â  Â  Â  }

Â  Â  Â  };

Â  Â  Â  editButton.onclick = (e) => {

Â  Â  Â  Â  e.stopPropagation();

Â  Â  Â  Â  if (typeof editNoteContent === 'function') editNoteContent(card, noteId, notaData, menuActions, editButton, deleteButton);

Â  Â  Â  Â  else console.error("FunciÃ³n editNoteContent no encontrada");

Â  Â  Â  };

Â  Â  Â  menuActions.appendChild(editButton);

Â  Â  Â  menuActions.appendChild(deleteButton);

Â  Â  Â  menuBar.appendChild(bubbleButton);

Â  Â  Â  menuBar.appendChild(menuActions);

Â  Â  Â  card.appendChild(menuBar);

Â  Â  Â  content.appendChild(card);

Â  Â  Â  gridItem.appendChild(content);

Â  Â  Â  // PosiciÃ³n Gridstack

Â  Â  Â  const pos = {

Â  Â  Â  Â  x: notaData.x,

Â  Â  Â  Â  y: notaData.y,

Â  Â  Â  Â  w: notaData.w || 2,

Â  Â  Â  Â  h: notaData.h || 4,

Â  Â  Â  Â  id: noteId,

Â  Â  Â  Â  autoPosition: (notaData.x === undefined || notaData.y === undefined)

Â  Â  Â  };

Â  Â  Â  gridItem.docData = notaData; // Guardar datos para referencia

Â  Â  Â  return {

Â  Â  Â  Â  element: gridItem,

Â  Â  Â  Â  position: pos

Â  Â  Â  };

Â  Â  }

Â  Â  // --- FUNCIÃ“N PARA EDITAR NOTA ---

Â  Â  function editNoteContent(card, noteId, notaData, menuActionsContainer, editButton, deleteButton) {

Â  Â  Â  let targetElement = card.querySelector('.note-content');

Â  Â  Â  if (!targetElement && notaData.url) { // Solo crear si es nota de imagen sin texto previo

Â  Â  Â  Â  targetElement = document.createElement('div');

Â  Â  Â  Â  targetElement.classList.add('note-content');

Â  Â  Â  Â  card.insertBefore(targetElement, card.querySelector('.menu-bar'));

Â  Â  Â  } else if (!targetElement && !notaData.url) { // Si es nota de texto, deberÃ­a existir; si no, hay error

Â  Â  Â  Â  console.error("Error: No se encontrÃ³ .note-content para editar texto en nota:", noteId);

Â  Â  Â  Â  return;

Â  Â  Â  }

Â  Â  Â  const isImageNote = !!notaData.url;

Â  Â  Â  const currentText = isImageNote ? (notaData.texto || '') : (notaData.nota || '');

Â  Â  Â  targetElement.innerHTML = '';

Â  Â  Â  const editInput = document.createElement('textarea');

Â  Â  Â  editInput.value = currentText;

Â  Â  Â  editInput.style.cssText = "width:100%; min-height:80px; height:auto; box-sizing:border-box; border:1px dashed #ccc; resize:vertical;";

Â  Â  Â  targetElement.appendChild(editInput);

Â  Â  Â  autoResizeTextarea(editInput);

Â  Â  Â  editInput.addEventListener('input', () => autoResizeTextarea(editInput));

Â  Â  Â  editInput.focus();

Â  Â  Â  const saveEditButton = document.createElement('button');

Â  Â  Â  saveEditButton.classList.add('menu-icon');

Â  Â  Â  saveEditButton.innerHTML = 'ğŸ’¾';

Â  Â  Â  saveEditButton.title = "Guardar";

Â  Â  Â  saveEditButton.onclick = (e) => {

Â  Â  Â  Â  e.stopPropagation();

Â  Â  Â  Â  const newText = editInput.value.trim();

Â  Â  Â  Â  const updateData = isImageNote ? {

Â  Â  Â  Â  Â  texto: newText || null

Â  Â  Â  Â  } : {

Â  Â  Â  Â  Â  nota: newText

Â  Â  Â  Â  };

Â  Â  Â  Â  saveEditButton.disabled = true;

Â  Â  Â  Â  saveEditButton.innerHTML = 'â³';

Â  Â  Â  Â  db.collection('notas').doc(noteId).update(updateData)

Â  Â  Â  Â  Â  .then(() => {

Â  Â  Â  Â  Â  Â  menuActionsContainer.replaceChild(editButton, saveEditButton);

Â  Â  Â  Â  Â  Â  menuActionsContainer.appendChild(deleteButton);

Â  Â  Â  Â  Â  }) // Restaurar botones originales

Â  Â  Â  Â  Â  .catch((error) => {

Â  Â  Â  Â  Â  Â  console.error('Error al actualizar:', error);

Â  Â  Â  Â  Â  Â  alert("Error al guardar.");

Â  Â  Â  Â  Â  Â  saveEditButton.disabled = false;

Â  Â  Â  Â  Â  Â  saveEditButton.innerHTML = 'ğŸ’¾';

Â  Â  Â  Â  Â  Â  menuActionsContainer.replaceChild(editButton, saveEditButton);

Â  Â  Â  Â  Â  Â  menuActionsContainer.appendChild(deleteButton);

Â  Â  Â  Â  Â  }); // Restaurar botones en error

Â  Â  Â  };

Â  Â  Â  menuActionsContainer.innerHTML = '';

Â  Â  Â  menuActionsContainer.appendChild(saveEditButton); // Mostrar solo guardar

Â  Â  }

Â  Â  // --- FUNCIÃ“N PARA ELIMINAR NOTA ---

Â  Â  function deleteNote(noteId, gridItem) {

Â  Â  Â  console.log("Eliminando nota:", noteId);

Â  Â  Â  db.collection('notas').doc(noteId).delete()

Â  Â  Â  Â  .then(() => {

Â  Â  Â  Â  Â  console.log(`Nota ${noteId} eliminada de Firestore.`);

Â  Â  Â  Â  Â  displayedNotes.delete(noteId);

Â  Â  Â  Â  Â  document.querySelectorAll(`.assigned-bubble[data-note='${noteId}']`).forEach(b => b.remove()); // Quitar del calendario

Â  Â  Â  Â  })

Â  Â  Â  Â  .catch((error) => {

Â  Â  Â  Â  Â  console.error("Error al eliminar:", error);

Â  Â  Â  Â  Â  alert("Error al eliminar la nota.");

Â  Â  Â  Â  });

Â  Â  }

Â  Â  /****************** Escucha de Cambios en Firestore (SIMPLIFICADA) ******************/

Â  Â  if (db && typeof db.collection === 'function') {

Â  Â  Â  db.collection('notas')

Â  Â  Â  Â  .onSnapshot((snapshot) => {

Â  Â  Â  Â  Â  if (!grid) {

Â  Â  Â  Â  Â  Â  console.error("GridStack no inicializado.");

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  let needsCalendarUpdate = false; // Bandera para saber si refrescar calendario

Â  Â  Â  Â  Â  // Procesamos SOLO los cambios detectados por Firestore

Â  Â  Â  Â  Â  snapshot.docChanges().forEach((change) => {

Â  Â  Â  Â  Â  Â  const noteId = change.doc.id;

Â  Â  Â  Â  Â  Â  const notaData = change.doc.data();

Â  Â  Â  Â  Â  Â  console.log(`Cambio detectado: Tipo=${change.type}, ID=${noteId}`); // Log para depurar

Â  Â  Â  Â  Â  Â  if (change.type === "added") {

Â  Â  Â  Â  Â  Â  Â  // Se aÃ±adiÃ³ una nueva nota a Firestore

Â  Â  Â  Â  Â  Â  Â  // Verificamos si ya existe en el grid (por si acaso, ej: carga inicial)

Â  Â  Â  Â  Â  Â  Â  const existingElement = grid.engine.nodes.find(n => n.id === noteId)?.el; // Busca por ID de gridstack

Â  Â  Â  Â  Â  Â  Â  // O alternativamente: document.querySelector(`.grid-stack-item[data-note-id="${noteId}"]`);

Â  Â  Â  Â  Â  Â  Â  if (!existingElement) {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`AÃ±adiendo widget para ${noteId}`);

Â  Â  Â  Â  Â  Â  Â  Â  const result = mostrarNotaEnPantalla(change.doc);

Â  Â  Â  Â  Â  Â  Â  Â  if (result) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  // AÃ±adimos el nuevo widget al grid

Â  Â  Â  Â  Â  Â  Â  Â  Â  grid.addWidget(result.element, result.position);

Â  Â  Â  Â  Â  Â  Â  Â  Â  if (notaData.assignedDate) needsCalendarUpdate = true; // Marcar si afecta calendario

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  console.log(`Widget para ${noteId} ya existÃ­a, no se aÃ±ade de nuevo.`);

Â  Â  Â  Â  Â  Â  Â  Â  // PodrÃ­amos querer actualizar su contenido/posiciÃ³n si los datos son diferentes

Â  Â  Â  Â  Â  Â  Â  Â  // (CÃ³digo de 'modified' podrÃ­a ir aquÃ­ tambiÃ©n para la carga inicial)

Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  } else if (change.type === "modified") {

Â  Â  Â  Â  Â  Â  Â  // Una nota existente cambiÃ³ (contenido, posiciÃ³n, fecha asignada)

Â  Â  Â  Â  Â  Â  Â  console.log(`Modificando widget para ${noteId}`);

Â  Â  Â  Â  Â  Â  Â  const widgetElement = grid.engine.nodes.find(n => n.id === noteId)?.el; // Busca por ID de gridstack

Â  Â  Â  Â  Â  Â  Â  // O alternativamente: document.querySelector(`.grid-stack-item[data-note-id="${noteId}"]`);

Â  Â  Â  Â  Â  Â  Â  if (widgetElement) {

Â  Â  Â  Â  Â  Â  Â  Â  const oldData = widgetElement.docData || {}; // Usamos los datos guardados en el elemento si existen

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Actualizar Contenido (Texto/Imagen) si cambiÃ³

Â  Â  Â  Â  Â  Â  Â  Â  const noteContentElement = widgetElement.querySelector('.note-content');

Â  Â  Â  Â  Â  Â  Â  Â  const newText = notaData.url ? (notaData.texto || '') : (notaData.nota || '');

Â  Â  Â  Â  Â  Â  Â  Â  const oldText = notaData.url ? (oldData.texto || '') : (oldData.nota || '');

Â  Â  Â  Â  Â  Â  Â  Â  if (noteContentElement && newText !== oldText) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(` - Actualizando contenido de texto para ${noteId}`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  noteContentElement.innerHTML = linkify(newText);

Â  Â  Â  Â  Â  Â  Â  Â  Â  // Re-aplicar target blank a los links si es necesario

Â  Â  Â  Â  Â  Â  Â  Â  Â  Array.from(noteContentElement.getElementsByTagName('a')).forEach(link => {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  link.setAttribute('target', '_blank');

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  link.setAttribute('rel', 'noopener noreferrer');

Â  Â  Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Si es imagen y la URL cambiÃ³ (menos comÃºn)

Â  Â  Â  Â  Â  Â  Â  Â  if (notaData.url && notaData.url !== oldData.url) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(` - Actualizando URL de imagen para ${noteId}`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  const img = widgetElement.querySelector('.image-container img');

Â  Â  Â  Â  Â  Â  Â  Â  Â  if (img) img.src = notaData.url;

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 2. Actualizar PosiciÃ³n si cambiÃ³ (y si no es la que estamos arrastrando nosotros mismos)

Â  Â  Â  Â  Â  Â  Â  Â  // (Puede ser complejo evitar actualizar si el cambio de X,Y fue por el drag local)

Â  Â  Â  Â  Â  Â  Â  Â  // Por ahora, actualizamos si Firestore dice que cambiÃ³:

Â  Â  Â  Â  Â  Â  Â  Â  if ((typeof notaData.x === 'number' && notaData.x !== oldData.x) || (typeof notaData.y === 'number' && notaData.y !== oldData.y)) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  // Solo si la posiciÃ³n en Firestore es diferente a la actual en GridStack

Â  Â  Â  Â  Â  Â  Â  Â  Â  const currentNode = grid.engine.nodes.find(n => n.id === noteId);

Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentNode && (currentNode.x !== notaData.x || currentNode.y !== notaData.y)) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(` - Actualizando posiciÃ³n para ${noteId} a (${notaData.x}, ${notaData.y})`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  //grid.update(widgetElement, {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  //x: notaData.x,

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  //y: notaData.y

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  //});

Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 3. Actualizar estado de la burbuja del calendario

Â  Â  Â  Â  Â  Â  Â  Â  const bubbleButton = widgetElement.querySelector(`#bubble-${noteId}`);

Â  Â  Â  Â  Â  Â  Â  Â  const needsBubble = !notaData.assignedDate; // Se muestra si NO tiene fecha

Â  Â  Â  Â  Â  Â  Â  Â  if (bubbleButton) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  const shouldDisplayBubble = bubbleButton.style.display !== 'none';

Â  Â  Â  Â  Â  Â  Â  Â  Â  if (needsBubble && !shouldDisplayBubble) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(` - Mostrando burbuja para ${noteId}`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bubbleButton.style.display = 'inline-block';

Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (!needsBubble && shouldDisplayBubble) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log(` - Ocultando burbuja para ${noteId}`);

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  bubbleButton.style.display = 'none';

Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Marcar si afecta calendario

Â  Â  Â  Â  Â  Â  Â  Â  if (notaData.assignedDate !== oldData.assignedDate) {

Â  Â  Â  Â  Â  Â  Â  Â  Â  needsCalendarUpdate = true;

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Actualizar los datos cacheados en el elemento

Â  Â  Â  Â  Â  Â  Â  Â  widgetElement.docData = notaData;

Â  Â  Â  Â  Â  Â  Â  Â  // Actualizar cachÃ© global para el calendario

Â  Â  Â  Â  Â  Â  Â  Â  notesDataCache[noteId] = notaData;

Â  Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  console.warn(`Se recibiÃ³ 'modified' para ${noteId}, pero no se encontrÃ³ el widget en el grid.`);

Â  Â  Â  Â  Â  Â  Â  Â  // PodrÃ­a ser una nota que se modificÃ³ y eliminÃ³ rÃ¡pidamente.

Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  } else if (change.type === "removed") {

Â  Â  Â  Â  Â  Â  Â  // Una nota fue eliminada de Firestore

Â  Â  Â  Â  Â  Â  Â  console.log(`Eliminando widget para ${noteId}`);

Â  Â  Â  Â  Â  Â  Â  const widgetElement = grid.engine.nodes.find(n => n.id === noteId)?.el;

Â  Â  Â  Â  Â  Â  Â  // O alternativamente: document.querySelector(`.grid-stack-item[data-note-id="${noteId}"]`);

Â  Â  Â  Â  Â  Â  Â  if (widgetElement) {

Â  Â  Â  Â  Â  Â  Â  Â  // Eliminamos el widget del grid

Â  Â  Â  Â  Â  Â  Â  Â  grid.removeWidget(widgetElement); // El tercer parÃ¡metro `false` evita que se guarde la eliminaciÃ³n (ya viene de Firestore)

Â  Â  Â  Â  Â  Â  Â  Â  if (notesDataCache[noteId]?.assignedDate) needsCalendarUpdate = true; // Marcar si afecta calendario

Â  Â  Â  Â  Â  Â  Â  Â  delete notesDataCache[noteId]; // Limpiar cachÃ©

Â  Â  Â  Â  Â  Â  Â  Â  // PodrÃ­amos necesitar limpiar `assignedDatesCache` tambiÃ©n, pero fetchAll lo harÃ¡

Â  Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  console.warn(`Se recibiÃ³ 'removed' para ${noteId}, pero no se encontrÃ³ el widget.`);
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }); // Fin del forEach(change)
Â  Â  Â  Â  Â  // Actualiza el calendario SI algÃºn cambio lo requiriÃ³
Â  Â  Â  Â  Â  if (needsCalendarUpdate && currentCalendarMonth !== undefined) {
Â  Â  Â  Â  Â  Â  console.log("Actualizando calendario debido a cambios...");
Â  Â  Â  Â  Â  Â  // Usamos fetchAllAssignedNotes para asegurar que la cachÃ© estÃ© actualizada
Â  Â  Â  Â  Â  Â  fetchAllAssignedNotes().then(() => {
Â  Â  Â  Â  Â  Â  Â  generateCalendar(currentCalendarMonth, currentCalendarYear);
Â  Â  Â  Â  Â  Â   // PodrÃ­as querer quitar tambiÃ©n las burbujas del DOM manualmente si es necesario
Â  Â  Â  Â  Â  Â  Â  // document.querySelectorAll(`.assigned-bubble[data-note='${noteId_eliminado}']`).forEach(b => b.remove());
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  } else if (needsCalendarUpdate) {
Â  Â  Â  Â  Â  Â  // Si el calendario no se ha mostrado nunca, solo actualizamos la cachÃ©
Â  Â  Â  Â  Â  Â  fetchAllAssignedNotes();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, (error) => {
Â  Â  Â  Â  Â  console.error("Error Firestore:", error);
Â  Â  Â  Â  Â  alert("Error al cargar notas.");
Â  Â  Â  Â  });
Â  Â  } else {
Â  Â  Â  console.error("Firestore (db) no inicializado.");
Â  Â  Â  alert("Error: No se pudo conectar a la base de datos.");
Â  Â  }

Â  Â  /****************** Manejo de la Interfaz para Agregar Notas ******************/
Â  Â  const addNoteButtonElem = document.getElementById('addNoteButton');
Â  Â  const addNoteOptionsElem = document.getElementById('addNoteOptions');
Â  Â  const addImageLinkOptionElem = document.getElementById('addImageLinkOption');
Â  Â  const addTextNoteOptionElem = document.getElementById('addTextNoteOption');
Â  Â  const inputAreaElem = document.getElementById('inputArea');
Â  Â  const imageLinkInputAreaElem = document.getElementById('imageLinkInputArea');
Â  Â  const imageLinkInputElem = document.getElementById('imageLink');
Â  Â  const saveImageLinkButtonElem = document.getElementById('saveImageLink');
Â  Â  const textNoteInputAreaElem = document.getElementById('textNoteInputArea');
Â  Â  const saveTextNoteButtonElem = document.getElementById('saveTextNote');
Â  Â  const blurBackgroundElem = document.querySelector('.blur-background');
Â  Â  function hideMenus() {

Â  Â  Â  if (addNoteOptionsElem) addNoteOptionsElem.style.display = 'none';
Â  Â  Â  if (inputAreaElem) inputAreaElem.style.display = 'none';
Â  Â  Â  if (blurBackgroundElem) blurBackgroundElem.style.display = 'none';
Â  Â  Â  if (imageLinkInputElem) imageLinkInputElem.value = '';
Â  Â  Â  if (imageNoteTextElem) {
Â  Â  Â  Â  imageNoteTextElem.value = '';
Â  Â  Â  Â  autoResizeTextarea(imageNoteTextElem);
Â  Â  Â  }

Â  Â  Â  if (textNoteInputElem) {
Â  Â  Â  Â  textNoteInputElem.value = '';
Â  Â  Â  Â  autoResizeTextarea(textNoteInputElem);
Â  Â  Â  }
Â  Â  }

Â  Â  if (addNoteButtonElem) addNoteButtonElem.onclick = (e) => {
Â  Â  Â  e.stopPropagation();
Â  Â  Â  if (addNoteOptionsElem && addNoteOptionsElem.style.display === 'flex') {
Â  Â  Â  Â  hideMenus();
Â  Â  Â  } else if (addNoteOptionsElem && blurBackgroundElem) {
Â  Â  Â  Â  hideMenus();
Â  Â  Â  Â  addNoteOptionsElem.style.display = 'flex';
Â  Â  Â  Â  blurBackgroundElem.style.display = 'block';
Â  Â  Â  }
Â  Â  };

Â  Â  if (addImageLinkOptionElem) addImageLinkOptionElem.onclick = (e) => {
Â  Â  Â  e.stopPropagation();
Â  Â  Â  if (addNoteOptionsElem) addNoteOptionsElem.style.display = 'none';
Â  Â  Â  if (imageLinkInputAreaElem) imageLinkInputAreaElem.style.display = 'block';
Â  Â  Â  if (textNoteInputAreaElem) textNoteInputAreaElem.style.display = 'none';
Â  Â  Â  if (inputAreaElem) inputAreaElem.style.display = 'flex';
Â  Â  Â  if (blurBackgroundElem) blurBackgroundElem.style.display = 'block';
Â  Â  Â  if (imageLinkInputElem) imageLinkInputElem.focus();

Â  Â  };

Â  Â  if (addTextNoteOptionElem) addTextNoteOptionElem.onclick = (e) => {
Â  Â  Â  e.stopPropagation();
Â  Â  Â  if (addNoteOptionsElem) addNoteOptionsElem.style.display = 'none';
Â  Â  Â  if (imageLinkInputAreaElem) imageLinkInputAreaElem.style.display = 'none';
Â  Â  Â  if (textNoteInputAreaElem) textNoteInputAreaElem.style.display = 'block';
Â  Â  Â  if (inputAreaElem) inputAreaElem.style.display = 'flex';
Â  Â  Â  if (blurBackgroundElem) blurBackgroundElem.style.display = 'block';
Â  Â  Â  if (textNoteInputElem) textNoteInputElem.focus();
Â  Â  };

Â  Â  if (blurBackgroundElem) blurBackgroundElem.onclick = hideMenus;

Â  Â // --- REEMPLAZA TU FUNCIÃ“N guardarLinkDeImagen COMPLETA POR ESTA ---
Â  Â  function guardarLinkDeImagen() {
Â  Â  Â  if (!imageLinkInputElem) return;
Â  Â  Â  let link = imageLinkInputElem.value.trim();
Â  Â  Â  const texto = imageNoteTextElem ? imageNoteTextElem.value.trim() : '';
Â  Â  Â  if (link) {
Â  Â  Â  Â  if (saveImageLinkButtonElem) saveImageLinkButtonElem.disabled = true;
Â  Â  Â  Â  db.collection('notas').add({
Â  Â  Â  Â  Â  url: link,
Â  Â  Â  Â  Â  texto: texto || null,
Â  Â  Â  Â  Â  createdAt: firebase.firestore.FieldValue.serverTimestamp(),
Â  Â  Â  Â  Â  tipo: 'imagen',
Â  Â  Â  Â  Â  // >>>>>>>>> AÃ‘ADE ESTAS DOS LÃNEAS AQUÃ para definir tamaÃ±o por defecto <<<<<<<<<
Â  Â  Â  Â  Â  w: 1, // Ancho por defecto (2 columnas)
Â  Â  Â  Â  Â  h: 1,Â  // Altura por defecto (4 filas)
Â  Â  Â  Â  Â  // >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Â  Â  Â  Â  })
Â  Â  Â  Â  .then(() => {
Â  Â  Â  Â  Â  hideMenus();
Â  Â  Â  Â  }).catch((error) => {
Â  Â  Â  Â  Â  console.error('Error al guardar link:', error);
Â  Â  Â  Â  Â  alert("Error al guardar imagen.");
Â  Â  Â  Â  })
Â  Â  Â  Â  .finally(() => {
Â  Â  Â  Â  Â  if (saveImageLinkButtonElem) saveImageLinkButtonElem.disabled = false;
Â  Â  Â  Â  });
Â  Â  Â  } else {
Â  Â  Â  Â  alert("Introduce un link vÃ¡lido.");
Â  Â  Â  Â  imageLinkInputElem.focus();
Â  Â  Â  }
Â  Â  }
// --- FIN DEL BLOQUE DE REEMPLAZO DE LA FUNCIÃ“N guardarLinkDeImagen ---
Â  Â  // --- REEMPLAZA TU FUNCIÃ“N guardarNotaTexto COMPLETA POR ESTA (CAMBIO 2) ---
function guardarNotaTexto()Â  {
Â  if (!textNoteInputElem) return;
Â  const nota = textNoteInputElem.value.trim();
Â  if (nota) {
Â  Â  if (saveTextNoteButtonElem) saveTextNoteButtonElem.disabled = true;
Â  Â  db.collection('notas').add({
Â  Â  Â  nota: nota,
Â  Â  Â  createdAt: firebase.firestore.FieldValue.serverTimestamp(),
Â  Â  Â  tipo: 'texto',
Â  Â  Â  // Define tamaÃ±o 2x2 en GridStack para notas de texto nuevas
Â  Â  Â  w: 1,
Â  Â  Â  h: 1,
Â  Â  })

Â  Â  .then(() => {
Â  Â  Â  hideMenus();
Â  Â  }).catch((error) => {
Â  Â  Â  console.error('Error al guardar nota:', error);
Â  Â  Â  alert("Error al guardar nota.");

Â  Â  })

Â  Â  .finally(() => {

Â  Â  Â  if (saveTextNoteButtonElem) saveTextNoteButtonElem.disabled = false;

Â  Â  });

Â  } else {

Â  Â  alert("Escribe algo en la nota.");

Â  Â  textNoteInputElem.focus();
Â  }
}

// --- FIN DEL BLOQUE DE REEMPLAZO DE LA FUNCIÃ“N guardarNotaTexto ---
// ... (el resto de tu cÃ³digo JavaScript, dÃ©jalo como estÃ¡) ...

Â  Â  if (saveImageLinkButtonElem) saveImageLinkButtonElem.onclick = guardarLinkDeImagen;
Â  Â  if (saveTextNoteButtonElem) saveTextNoteButtonElem.onclick = guardarNotaTexto;

Â  Â  /****************** Calendario y AsignaciÃ³n de la Burbuja ******************/
Â  Â  let currentCalendarMonth, currentCalendarYear;
Â  Â  let assignedDatesCache = {};
Â  Â  let notesDataCache = {};
Â  Â  function getChileDate() {
Â  Â  Â  try {
Â  Â  Â  Â  const opts = {
Â  Â  Â  Â  Â  timeZone: 'America/Santiago',
Â  Â  Â  Â  Â  year: 'numeric',
Â  Â  Â  Â  Â  month: 'numeric',
Â  Â  Â  Â  Â  day: 'numeric',
Â  Â  Â  Â  Â  hour: 'numeric',
Â  Â  Â  Â  Â  minute: 'numeric',
Â  Â  Â  Â  Â  second: 'numeric',
Â  Â  Â  Â  Â  hour12: false

Â  Â  Â  Â  };
Â  Â  Â  Â  const fmt = new Intl.DateTimeFormat('en-CA', opts);
Â  Â  Â  Â  const p = fmt.formatToParts(new Date());
Â  Â  Â  Â  const d = {};
Â  Â  Â  Â  p.forEach(({
Â  Â  Â  Â  Â  type,
Â  Â  Â  Â  Â  value
Â  Â  Â  Â  }) => d[type] = parseInt(value, 10));
Â  Â  Â  Â  return new Date(Date.UTC(d.year, d.month - 1, d.day, d.hour, d.minute, d.second));
Â  Â  Â  } catch (e) {
Â  Â  Â  Â  console.warn("Intl fallback", e);
Â  Â  Â  Â  return new Date();
Â  Â  Â  }
Â  Â  }
Â  Â  function initCalendarDate() {
Â  Â  Â  let today = getChileDate();
Â  Â  Â  let year = today.getFullYear();
Â  Â  Â  let month = today.getMonth();
Â  Â  Â  const minY = 2024;
Â  Â  Â  const minM = 11;
Â  Â  Â  if (year < minY || (year === minY && month < minM)) {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  month: minM,
Â  Â  Â  Â  Â  year: minY
Â  Â  Â  Â  };
Â  Â  Â  }
Â  Â  Â  return {
Â  Â  Â  Â  month,
Â  Â  Â  Â  year
Â  Â  Â  };

Â  Â  }
Â  Â  function getMonthName(idx) {
Â  Â  Â  const months = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
Â  Â  Â  return months[idx % 12] || '';

Â  Â  }

Â  Â  async function fetchAllAssignedNotes() {

Â  Â  Â  assignedDatesCache = {};

Â  Â  Â  notesDataCache = {};

Â  Â  Â  try {

Â  Â  Â  Â  const snap = await db.collection('notas').where('assignedDate', '!=', null).get();

Â  Â  Â  Â  snap.forEach(doc => {

Â  Â  Â  Â  Â  const d = doc.data();

Â  Â  Â  Â  Â  const id = doc.id;

Â  Â  Â  Â  Â  notesDataCache[id] = d;

Â  Â  Â  Â  Â  const dateStr = d.assignedDate;

Â  Â  Â  Â  Â  if (dateStr) {

Â  Â  Â  Â  Â  Â  if (!assignedDatesCache[dateStr]) assignedDatesCache[dateStr] = [];

Â  Â  Â  Â  Â  Â  if (!assignedDatesCache[dateStr].includes(id)) assignedDatesCache[dateStr].push(id);

Â  Â  Â  Â  Â  }

Â  Â  Â  Â  });

Â  Â  Â  } catch (err) {

Â  Â  Â  Â  console.error("Error fetch dates:", err);

Â  Â  Â  }

Â  Â  }

Â  Â  async function generateCalendar(month, year) {

Â  Â  Â  if (Object.keys(notesDataCache).length === 0) await fetchAllAssignedNotes();

Â  Â  Â  const calDiv = document.getElementById('calendarWidget');

Â  Â  Â  if (!calDiv) return;

Â  Â  Â  calDiv.innerHTML = '';

Â  Â  Â  const today = getChileDate();

Â  Â  Â  const hdr = document.createElement('div');

Â  Â  Â  hdr.className = 'calendar-header';

Â  Â  Â  const pBtn = document.createElement('button');

Â  Â  Â  pBtn.innerHTML = '&lt;';

Â  Â  Â  const minY = 2024;

Â  Â  Â  const minM = 11;

Â  Â  Â  if (year === minY && month === minM) pBtn.disabled = true;

Â  Â  Â  else pBtn.onclick = () => generateCalendar(month === 0 ? 11 : month - 1, month === 0 ? year - 1 : year);

Â  Â  Â  const nBtn = document.createElement('button');

Â  Â  Â  nBtn.innerHTML = '&gt;';

Â  Â  Â  nBtn.onclick = () => generateCalendar(month === 11 ? 0 : month + 1, month === 11 ? year + 1 : year);

Â  Â  Â  const title = document.createElement('span');

Â  Â  Â  title.textContent = `${getMonthName(month)} ${year}`;

Â  Â  Â  hdr.appendChild(pBtn);

Â  Â  Â  hdr.appendChild(title);

Â  Â  Â  hdr.appendChild(nBtn);

Â  Â  Â  calDiv.appendChild(hdr);

Â  Â  Â  const daysHdr = document.createElement('div');

Â  Â  Â  daysHdr.className = 'calendar-days-header';

Â  Â  Â  ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'SÃ¡'].forEach(day => {

Â  Â  Â  Â  const d = document.createElement('div');

Â  Â  Â  Â  d.className = 'calendar-day';

Â  Â  Â  Â  d.textContent = day;

Â  Â  Â  Â  daysHdr.appendChild(d);

Â  Â  Â  });

Â  Â  Â  calDiv.appendChild(daysHdr);

Â  Â  Â  const datesG = document.createElement('div');

Â  Â  Â  datesG.className = 'calendar-dates-grid';

Â  Â  Â  const firstD = new Date(year, month, 1).getDay();

Â  Â  Â  const daysInM = new Date(year, month + 1, 0).getDate();

Â  Â  Â  for (let i = 0; i < firstD; i++) {

Â  Â  Â  Â  const e = document.createElement('div');

Â  Â  Â  Â  e.className = 'calendar-date empty';

Â  Â  Â  Â  datesG.appendChild(e);

Â  Â  Â  }

Â  Â  Â  for (let date = 1; date <= daysInM; date++) {

Â  Â  Â  Â  const cell = document.createElement('div');

Â  Â  Â  Â  cell.className = 'calendar-date';

Â  Â  Â  Â  cell.textContent = date;

Â  Â  Â  Â  const dStr = `${date}/${month + 1}/${year}`;

Â  Â  Â  Â  if (date === today.getDate() && month === today.getMonth() && year === today.getFullYear()) cell.classList.add('today');

Â  Â  Â  Â  if (assignedDatesCache[dStr]) {

Â  Â  Â  Â  Â  assignedDatesCache[dStr].forEach(id => {

Â  Â  Â  Â  Â  Â  const b = document.createElement("span");

Â  Â  Â  Â  Â  Â  b.className = "assigned-bubble";

Â  Â  Â  Â  Â  Â  b.setAttribute("data-note", id);

Â  Â  Â  Â  Â  Â  b.textContent = "â—";

Â  Â  Â  Â  Â  Â  cell.appendChild(b);

Â  Â  Â  Â  Â  });

Â  Â  Â  Â  }

Â  Â  Â  Â  cell.addEventListener('dragover', (e) => {

Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  e.dataTransfer.dropEffect = "move";
Â  Â  Â  Â   cell.classList.add('drag-over');
Â  Â  Â  Â  });
Â  Â  Â  Â  cell.addEventListener('dragleave', (e) => {
Â  Â  Â  Â  Â  cell.classList.remove('drag-over');
Â  Â  Â  Â  });
Â  Â  Â  Â  cell.addEventListener('drop', async (e) => {
Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  cell.classList.remove('drag-over');
Â  Â  Â  Â  Â  const noteId = e.dataTransfer.getData("application/note-id");
Â  Â  Â  Â  Â  if (noteId) {
Â  Â  Â  Â  Â  Â  const oldDStr = notesDataCache[noteId]?.assignedDate;
Â  Â  Â  Â  Â  Â  try {

Â  Â  Â  Â  Â  Â  Â  await db.collection('notas').doc(noteId).update({

Â  Â  Â  Â  Â  Â  Â  Â  assignedDate: dStr

Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  if (notesDataCache[noteId]) notesDataCache[noteId].assignedDate = dStr;
Â  Â  Â  Â  Â  Â  Â  else notesDataCache[noteId] = {

Â  Â  Â  Â  Â  Â  Â  Â  assignedDate: dStr

Â  Â  Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  Â  Â  if (oldDStr && assignedDatesCache[oldDStr]) {
Â  Â  Â  Â  Â  Â  Â  Â  assignedDatesCache[oldDStr] = assignedDatesCache[oldDStr].filter(id => id !== noteId);
Â  Â  Â  Â  Â  Â  Â  Â  if (assignedDatesCache[oldDStr].length === 0) delete assignedDatesCache[oldDStr];
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  if (!assignedDatesCache[dStr]) assignedDatesCache[dStr] = [];
Â  Â  Â  Â  Â  Â  Â  if (!assignedDatesCache[dStr].includes(noteId)) assignedDatesCache[dStr].push(noteId);
Â  Â  Â  Â  Â  Â  Â  const bubbleInC = document.getElementById(`bubble-${noteId}`);
Â  Â  Â  Â  Â  Â  Â  if (bubbleInC) bubbleInC.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  generateCalendar(currentCalendarMonth, currentCalendarYear);
Â  Â  Â  Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  Â  Â  console.error(`Err assign date ${noteId}:`, err);
Â  Â  Â  Â  Â  Â  Â  alert("Error.");
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  datesG.appendChild(cell);
Â  Â  Â  }
Â  Â  Â  const totalC = firstD + daysInM;
Â  Â  Â  const cellsN = totalC <= 35 ? 35 : 42;
Â  Â  Â  for (let i = totalC; i < cellsN; i++) {
Â  Â  Â  Â  const e = document.createElement('div');
Â  Â  Â  Â  e.className = 'calendar-date empty';

Â  Â  Â  Â  datesG.appendChild(e);
Â  Â  Â  }
Â  Â  Â  calDiv.appendChild(datesG);
Â  Â  Â  currentCalendarMonth = month;
Â  Â  Â  currentCalendarYear = year;
Â  Â  }
Â  Â  const calendarIconElem = document.getElementById('calendarIcon');
Â  Â  const calendarWidgetElem = document.getElementById('calendarWidget');
Â  Â  let calendarTimeout;
Â  Â  function showCalendar() {
Â  Â  Â  if (!calendarWidgetElem) return;
Â  Â  Â  clearTimeout(calendarTimeout);
Â  Â  Â  if (calendarWidgetElem.style.display !== 'block') {

Â  Â  Â  Â  const {
Â  Â  Â  Â  Â  month,
Â  Â  Â  Â  Â  year

Â  Â  Â  Â  } = initCalendarDate();
Â  Â  Â  Â  generateCalendar(month, year);
Â  Â  Â  Â  calendarWidgetElem.style.display = 'block';
Â  Â  Â  }

Â  Â  }
Â  Â  function hideCalendar() {
Â  Â  Â  if (!calendarWidgetElem) return;
Â  Â  Â  calendarTimeout = setTimeout(() => {
Â  Â  Â  Â  calendarWidgetElem.style.display = 'none';
Â  Â  Â  }, 300);

Â  Â  }
Â  Â  if (calendarIconElem) {

Â  Â  Â  calendarIconElem.addEventListener('mouseenter', showCalendar);
Â  Â  Â  calendarIconElem.addEventListener('mouseleave', hideCalendar);
Â  Â  }

Â  Â  if (calendarWidgetElem) {
Â  Â  Â  calendarWidgetElem.addEventListener('mouseenter', () => clearTimeout(calendarTimeout));
Â  Â  Â  calendarWidgetElem.addEventListener('mouseleave', hideCalendar);
Â  Â  }
Â  Â  function openCalendar() {
Â  Â  Â  showCalendar();
Â  Â  }
Â  Â  // --- Variables para guardar la posiciÃ³n original al arrastrar ---
Â  Â  let originalDragX = null;
Â  Â  let originalDragY = null;

Â  </script>
</body>
</html>
