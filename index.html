<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Notas Oce√°nicas - Polaroid</title>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-firestore-compat.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@8.3.0/dist/gridstack.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/gridstack@8.3.0/dist/gridstack-all.js"></script>
  <style>
    /* Estilos CSS (Manteniendo los estilos originales) */
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      overflow: hidden; /* Evita scroll en el body */
      background: linear-gradient(to bottom, #a2dff7 0%, #a2dff7 40%, #03254c 100%);
      font-family: Arial, sans-serif;
    }
    .container {
      height: 100%;
      width: 100%;
      padding: 2cm; /* Considerar usar unidades relativas como % o vw/vh para mejor adaptabilidad */
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden; /* Contenedor principal no debe hacer scroll */
    }
    #notaDisplay {
      flex-grow: 1; /* Ocupa el espacio restante */
      width: 100%;
      overflow-y: auto; /* Permite scroll vertical DENTRO del grid */
      overflow-x: hidden; /* Oculta scroll horizontal */
      position: relative; /* Necesario para GridStack */
      background-color: rgba(255, 255, 255, 0.1); /* Fondo sutil para ver el √°rea */
      border-radius: 5px;
    }
    .grid-stack-placeholder { display: none !important; } /* Oculta el placeholder visual de Gridstack */
    .grid-stack-item {
      transition: transform 0.4s cubic-bezier(0.25,1,0.5,1); /* Animaci√≥n suave al mover */
      overflow: visible !important; /* Permite que sombras/elementos sobresalgan */
    }
    .grid-stack-item-content {
        overflow: visible !important; /* Permite que contenido interno sobresalga */
        height: 100%; /* Ocupa toda la altura del item */
        width: 100%;
        display: flex;
        flex-direction: column;
        background-color: #fff; /* Fondo blanco por defecto para el contenido */
        border-radius: 8px; /* Bordes redondeados */
        box-shadow: 0 4px 8px rgba(0,0,0,0.2); /* Sombra */
        border: 1px solid #0077a3; /* Borde sutil */
    }
    /* Ajuste para que el grid no tenga padding inferior excesivo */
    .grid-stack {
        padding-bottom: 1px;
    }

    /* Estilos de las Tarjetas (Imagen y Texto) */
    .card-wrapper, .text-card {
        /* Los estilos base ahora est√°n en .grid-stack-item-content */
        display: flex;
        flex-direction: column;
        position: relative;
        height: 100%; /* Asegura que ocupe todo el espacio del content */
        box-sizing: border-box;
    }
    .image-container {
        width: 100%;
        height: 240px; /* Altura fija para la imagen */
        overflow: hidden;
        position: relative;
        flex-shrink: 0; /* Evita que se encoja */
        border-top-left-radius: 8px; /* Redondeo superior */
        border-top-right-radius: 8px;
    }
    .image-container img {
        width: 100%;
        height: 100%;
        object-fit: cover; /* Cubre el contenedor sin distorsionar */
        display: block;
    }
    .note-content {
        background-color: #fff;
        padding: 12px; /* M√°s padding */
        text-align: left;
        font-size: 15px; /* Ligeramente m√°s peque√±o */
        color: #333;
        min-height: 40px; /* Altura m√≠nima */
        box-sizing: border-box;
        word-wrap: break-word; /* Rompe palabras largas */
        overflow: hidden; /* Oculta desbordamiento */
        flex-grow: 1; /* Ocupa espacio restante */
        line-height: 1.4; /* Mejor interlineado */
    }
    .note-content a { color: #0077a3; text-decoration: underline; }
    .note-content a:hover { color: #0288D1; }

    /* Barra de Men√∫ inferior de la tarjeta */
    .menu-bar {
        background-color: #f0f0f0; /* Fondo m√°s claro */
        padding: 4px 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        border-top: 1px solid #ddd; /* Borde superior */
        border-bottom-left-radius: 8px; /* Redondeo inferior */
        border-bottom-right-radius: 8px;
    }
    .menu-icon {
        background: none;
        border: none;
        font-size: 18px; /* Iconos ligeramente m√°s peque√±os */
        color: #555; /* Color gris oscuro */
        cursor: pointer;
        padding: 3px 5px;
        border-radius: 4px;
        transition: background-color 0.2s ease, color 0.2s ease;
    }
    .menu-icon:hover {
        background-color: #e0e0e0;
        color: #000;
    }
    .bubble-icon {
        color: #FFB300; /* Naranja/Amarillo */
        font-size: 20px;
    }
    .bubble-icon:hover {
        color: #FFA000;
    }
    .menu-actions {
        display: flex;
        gap: 4px;
    }

    /* Bot√≥n Flotante A√±adir (+) */
    #addNoteButton {
        position: absolute; /* Fijado respecto a .container */
        bottom: 30px;
        right: 30px;
        background-color: #006994;
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        font-size: 30px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        transition: background-color 0.3s ease, transform 0.3s ease;
        z-index: 1001; /* Encima del grid pero debajo de los modales */
    }
    #addNoteButton:hover {
        background-color: #005577;
        transform: scale(1.05);
    }

    /* Opciones de A√±adir Nota (Modal) */
    #addNoteOptions {
        position: fixed; /* Fijo en la ventana */
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(40, 40, 40, 0.9); /* Fondo oscuro semitransparente */
        backdrop-filter: blur(5px); /* Desenfoque del fondo */
        -webkit-backdrop-filter: blur(5px);
        border-radius: 10px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.4);
        display: none; /* Oculto por defecto */
        flex-direction: row;
        justify-content: center;
        align-items: center;
        gap: 25px;
        padding: 30px 35px;
        z-index: 1002; /* Encima del bot√≥n + y fondo blur */
    }
    #addNoteOptions .card {
        background-color: #3a3a3a; /* Gris oscuro */
        border: 1px solid #0077a3;
        border-radius: 8px;
        padding: 20px;
        text-align: center;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        width: 180px;
        color: #eee; /* Texto claro */
    }
    #addNoteOptions .card:hover {
        transform: translateY(-5px) scale(1.03);
        box-shadow: 0 6px 12px rgba(0, 119, 163, 0.5);
    }
    #addNoteOptions .card h2 { color: #64c8ff; margin-bottom: 10px; }
    #addNoteOptions .card p { color: #ccc; font-size: 14px; }

    /* √Årea de Input (Modal) */
    #inputArea {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: #ffffff;
        padding: 25px 30px;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        display: none; /* Oculto por defecto */
        flex-direction: column;
        gap: 15px;
        width: 90%;
        max-width: 550px;
        z-index: 1002; /* Mismo nivel que las opciones */
    }
    #inputArea label {
        font-weight: bold;
        color: #333;
        margin-bottom: 3px;
        font-size: 14px;
    }
    #inputArea textarea,
    #inputArea input[type="text"] {
        padding: 12px;
        border: 1px solid #ccc;
        border-radius: 4px;
        resize: vertical;
        width: 100%;
        box-sizing: border-box;
        line-height: 1.5;
        font-size: 16px;
        background-color: #f9f9f9; /* Fondo ligero */
    }
    #inputArea textarea:focus,
    #inputArea input[type="text"]:focus {
        border-color: #0077a3;
        box-shadow: 0 0 0 2px rgba(0, 119, 163, 0.2);
        outline: none;
    }
    #inputArea textarea { min-height: 80px; }
    #inputArea textarea#textNote { min-height: 120px; }
    #inputArea button {
        padding: 10px 20px;
        background-color: #006994;
        color: #fff;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.3s ease, transform 0.1s ease;
        align-self: flex-end;
        margin-top: 10px;
        font-size: 16px;
        font-weight: bold;
    }
    #inputArea button:hover { background-color: #005577; }
    #inputArea button:active { transform: scale(0.98); }
    #inputArea button:disabled { background-color: #aaa; cursor: not-allowed; } /* Estilo para bot√≥n deshabilitado */

    .input-group { display: flex; flex-direction: column; gap: 5px; width: 100%;}

    /* Icono y Widget del Calendario */
    .calendar-icon {
        position: absolute;
        bottom: 30px;
        left: 30px;
        width: 45px;
        height: 45px;
        background-color: #fff;
        border: 1px solid #ccc;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #333;
        font-size: 24px;
        cursor: pointer;
        z-index: 1001;
        box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        transition: transform 0.2s ease;
    }
    .calendar-icon:hover {
        transform: scale(1.1);
    }
    .calendar-widget {
        position: absolute; /* Posicionado relativo a .container */
        bottom: 85px; /* Encima del icono */
        left: 20px;
        background: #fff;
        border: 1px solid #ddd;
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        padding: 15px;
        display: none; /* Oculto por defecto */
        z-index: 1001; /* Mismo nivel que el icono */
        width: 320px;
        min-height: 300px; /* Altura m√≠nima para evitar colapso */
    }
    .calendar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }
    .calendar-header button {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 20px;
        color: #0077a3;
        padding: 5px 8px;
        border-radius: 4px;
        transition: background-color 0.2s ease;
    }
    .calendar-header button:hover:not(:disabled) { background-color: #e0f7fa; }
    .calendar-header button:disabled { color: #ccc; cursor: default; }
    .calendar-header span { font-weight: bold; color: #333; font-size: 18px; }
    .calendar-days-header,
    .calendar-dates-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        text-align: center;
        gap: 6px; /* Espacio entre celdas */
    }
    .calendar-days-header {
        margin-bottom: 10px;
        font-weight: bold;
        color: #555;
        padding-bottom: 8px;
        border-bottom: 1px solid #eee;
        font-size: 13px;
    }
    .calendar-day { padding: 3px; }
    .calendar-date {
        padding: 0;
        border-radius: 50%; /* Celdas redondas */
        color: #333;
        border: 2px solid transparent; /* Borde transparente para mantener tama√±o */
        cursor: pointer;
        position: relative;
        width: 36px; /* Tama√±o fijo */
        height: 36px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto; /* Centrado en la celda del grid */
        line-height: 1;
        font-size: 14px;
        transition: background-color 0.2s ease, border-color 0.2s ease;
    }
    .calendar-date.empty {
        background: none;
        cursor: default;
        opacity: 0; /* Completamente invisible */
    }
    .calendar-date:not(.empty):hover {
        background-color: #e0f7fa; /* Azul claro al pasar el rat√≥n */
        border-color: #b3e5fc;
    }
    .calendar-date.today {
        border-color: #0077a3; /* Borde azul oscuro para hoy */
        font-weight: bold;
        color: #005577;
    }
    .calendar-date.drag-over {
        background-color: #a2dff7 !important; /* Fondo azul m√°s intenso al arrastrar sobre √©l */
        border-color: #0077a3 !important;
        transform: scale(1.1); /* Ligeramente m√°s grande */
    }
    .assigned-bubble {
        color: #FFB300; /* Mismo color que el icono de la tarjeta */
        font-size: 11px; /* Tama√±o peque√±o */
        position: absolute;
        bottom: 3px; /* Posici√≥n en la parte inferior */
        left: 50%;
        transform: translateX(-50%);
        line-height: 1;
        text-shadow: 0 0 1px rgba(0,0,0,0.5); /* Sombra sutil */
        pointer-events: none; /* No interfiere con el drag/drop */
    }
    /* Permite apilar m√∫ltiples burbujas (aunque visualmente puede ser confuso) */
    .calendar-date .assigned-bubble + .assigned-bubble {
        bottom: -2px; /* Ajuste para la segunda burbuja */
    }

    /* Fondo Borroso (Overlay) */
    .blur-background {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6); /* Fondo oscuro semitransparente */
        backdrop-filter: blur(6px); /* Desenfoque */
        -webkit-backdrop-filter: blur(6px);
        display: none; /* Oculto por defecto */
        z-index: 1000; /* Debajo de los modales */
        cursor: pointer; /* Indica que se puede hacer clic para cerrar */
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="notaDisplay" class="grid-stack"></div>

    <button id="addNoteButton" title="A√±adir nueva nota o imagen">+</button>

    <div id="addNoteOptions">
      <div class="card" id="addImageLinkOption" title="A√±adir una nota con imagen desde un enlace web">
        <h2>üñºÔ∏è Imagen</h2>
        <p>Guardar link de imagen.</p>
      </div>
      <div class="card" id="addTextNoteOption" title="A√±adir una nota de texto simple">
        <h2>üìù Nota</h2>
        <p>Subir nota de texto.</p>
      </div>
    </div>

    <div id="inputArea">
      <div id="imageLinkInputArea" style="display: none;">
        <div class="input-group">
          <label for="imageLink">Link de la imagen:</label>
          <input type="text" id="imageLink" placeholder="Pega aqu√≠ la URL de la imagen (ej: https://...)" />
        </div>
        <div class="input-group">
          <label for="imageNoteText">Texto adicional (opcional):</label>
          <textarea id="imageNoteText" placeholder="Escribe aqu√≠ una descripci√≥n o nota relacionada con la imagen..." rows="3"></textarea>
        </div>
        <button id="saveImageLink">Guardar Imagen</button>
      </div>
      <div id="textNoteInputArea" style="display: none;">
       <div class="input-group">
          <label for="textNote">Nota:</label>
          <textarea id="textNote" placeholder="Escribe tu nota aqu√≠..." rows="5"></textarea>
        </div>
        <button id="saveTextNote">Guardar Nota</button>
      </div>
    </div>

    <div id="calendarIcon" class="calendar-icon" title="Mostrar/Ocultar Calendario">üìÖ</div>
    <div id="calendarWidget" class="calendar-widget"></div>

    <div class="blur-background"></div>
  </div>

  <script>
    /**************************************************************************
     * Utilidades y Configuraci√≥n de Firebase
     **************************************************************************/

    /**
     * Convierte URLs en texto a enlaces HTML <a> y reemplaza saltos de l√≠nea con <br>.
     * @param {string} text - El texto a procesar.
     * @returns {string} - El texto con enlaces y saltos de l√≠nea HTML.
     */
    function linkify(text) {
      if (!text) return "";
      // Regex mejorada para evitar convertir URLs dentro de atributos href o src
      const urlRegex = /(?<!href=["']|src=["'])(https?:\/\/[^\s<>"']+)/g;
      const replacedText = text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
      return replacedText.replace(/\n/g, '<br>'); // Convierte saltos de l√≠nea a <br>
    }

    // --- Configuraci√≥n de Firebase ---
    // !! IMPORTANTE: NUNCA EXPONGAS TU API KEY DIRECTAMENTE EN EL C√ìDIGO CLIENTE !!
    // !! ESTO ES UN RIESGO DE SEGURIDAD GRAVE. USA FIREBASE APP CHECK Y/O BACKEND !!
    const firebaseConfig = {
        apiKey: "YOUR_API_KEY", // <-- REEMPLAZA CON TU KEY, PERO CONSIDERA LAS ADVERTENCIAS
        authDomain: "oasis-b036d.firebaseapp.com",
        projectId: "oasis-b036d",
        storageBucket: "oasis-b036d.appspot.com",
        messagingSenderId: "141546637821",
        appId: "1:141546637821:web:0a861aeb13831774ed3194",
        measurementId: "G-HB2P17H5YL"
    };

    let db; // Variable global para la instancia de Firestore
    try {
        firebase.initializeApp(firebaseConfig);
        db = firebase.firestore(); // Obtiene la instancia de Firestore
        console.log("Firebase inicializado correctamente.");
    } catch (e) {
        console.error("Error inicializando Firebase:", e);
        alert("Error cr√≠tico: No se pudo conectar a la base de datos. La aplicaci√≥n no funcionar√° correctamente.");
    }

    /**************************************************************************
     * Inicializaci√≥n de GridStack
     **************************************************************************/
    let grid; // Variable global para la instancia de GridStack
    const gridContainer = document.getElementById('notaDisplay'); // Contenedor del grid

    if (gridContainer && typeof GridStack !== 'undefined') {
        try {
            grid = GridStack.init({
                column: 24, // N√∫mero de columnas (ajusta seg√∫n necesidad)
                margin: 10, // Margen entre widgets
                cellHeight: 'auto', // Altura de celda autom√°tica
                disableResize: true, // Deshabilitar redimensionamiento por el usuario
                float: false, // Los widgets no flotan hacia arriba
                animate: true, // Animar cambios
                alwaysShowResizeHandle: false, // No mostrar el handle de redimensionar
                draggable: {
                    handle: '.menu-bar', // Solo se puede arrastrar desde la barra de men√∫
                    scroll: true, // Permitir scroll de la p√°gina mientras se arrastra
                    appendTo: 'body' // Adjuntar el helper de arrastre al body
                }
            });
            console.log("GridStack inicializado correctamente.");

            /****************** Escucha de Cambios en GridStack (Arrastrar/Soltar) ******************/
            // Evento 'change': Se dispara despu√©s de que uno o m√°s widgets cambian (a√±adido, movido, eliminado).
            // Es el lugar ideal para guardar la posici√≥n final despu√©s de un arrastre.
            grid.on('change', function(event, items) {
                console.log("Evento 'change' de GridStack:", items.length, "elementos cambiaron.");
                items.forEach(function(item) {
                    const noteId = item.el?.getAttribute('data-note-id');
                    // Asegurarse de que tenemos un ID y coordenadas v√°lidas
                    if (noteId && typeof item.x === 'number' && typeof item.y === 'number') {
                        console.log(`   - Guardando posici√≥n para Nota ID: ${noteId} -> x:${item.x}, y:${item.y}`);
                        // Actualiza la posici√≥n en Firestore. Usamos update para no sobreescribir otros campos.
                        db.collection('notas').doc(noteId).update({ x: item.x, y: item.y })
                            .catch(err => console.error(`Error guardando posici√≥n desde 'change' para ${noteId}: ${err}`));
                    } else {
                         console.warn(`   - No se pudo guardar posici√≥n para el elemento. Faltan datos. ID: ${noteId}, x:${item.x}, y:${item.y}`);
                    }
                });
            });

            // Evento 'dragstop': Se dispara cuando el usuario suelta un widget despu√©s de arrastrarlo.
            // √ötil para depuraci√≥n o acciones inmediatas al soltar, pero 'change' es mejor para guardar el estado final.
            grid.on('dragstop', function(event, element) {
                const node = grid.engine.nodes.find(n => n.el === element);
                if (node) {
                    const noteId = node.el?.getAttribute('data-note-id') || node.id || '(desconocido)';
                    console.log(`Evento 'dragstop' de GridStack: Nota ID: ${noteId} soltada en x=${node.x}, y=${node.y}`);
                }
            });

            console.log(">>> Listeners de eventos de GridStack adjuntados <<<");

        } catch (e) {
            console.error("Error inicializando GridStack:", e);
            alert("Error al iniciar el √°rea de notas. Intenta recargar la p√°gina.");
        }
    } else {
        console.error("Error: No se encontr√≥ el contenedor del grid (#notaDisplay) o la librer√≠a GridStack no est√° cargada.");
        alert("Error cr√≠tico: No se puede inicializar el √°rea de notas.");
    }

    /**************************************************************************
     * Utilidades UI (Scroll, Redimensionar Textarea)
     **************************************************************************/

    // Prevenir scroll del body cuando se hace scroll sobre el grid (mejora UX)
    if (gridContainer) {
        gridContainer.addEventListener('wheel', (event) => {
            // Permite el scroll vertical normal dentro del contenedor
        }, { passive: true }); // passive:true para mejor rendimiento
    }

    /**
     * Ajusta autom√°ticamente la altura de un textarea a su contenido.
     * @param {HTMLTextAreaElement} el - El elemento textarea.
     */
    function autoResizeTextarea(el) {
        if (!el) return;
        el.style.height = 'auto'; // Resetea la altura
        el.style.height = (el.scrollHeight + 2) + 'px'; // Ajusta a la altura del scroll + peque√±o margen
    }

    // Elementos de textarea para auto-redimensionar
    const textNoteInputElem = document.getElementById('textNote');
    const imageNoteTextElem = document.getElementById('imageNoteText');
    if (textNoteInputElem) textNoteInputElem.addEventListener('input', () => autoResizeTextarea(textNoteInputElem));
    if (imageNoteTextElem) imageNoteTextElem.addEventListener('input', () => autoResizeTextarea(imageNoteTextElem));

    /**************************************************************************
     * Renderizaci√≥n, Edici√≥n y Eliminaci√≥n de Notas
     **************************************************************************/

    // Map para mantener una referencia a los datos de las notas mostradas (√∫til para comparar cambios)
    // const displayedNotes = new Map(); // Considerar si realmente se necesita vs. usar widget.docData

    /**
     * Crea el elemento HTML para una nota (imagen o texto) para ser a√±adido a GridStack.
     * @param {firebase.firestore.DocumentSnapshot} doc - El documento de Firestore con los datos de la nota.
     * @returns {object|null} - Un objeto { element: HTMLElement, position: object } o null si hay error.
     */
    function crearWidgetNota(doc) {
        const notaData = doc.data();
        const noteId = doc.id;

        // --- Crear elemento base del widget ---
        let gridItem = document.createElement('div');
        gridItem.classList.add('grid-stack-item');
        gridItem.setAttribute('data-note-id', noteId); // Guardar ID de Firestore en el elemento
        gridItem.setAttribute('gs-id', noteId); // Usar ID de Firestore como ID de GridStack

        // --- Crear contenido interno del widget ---
        const content = document.createElement('div');
        content.classList.add('grid-stack-item-content'); // El contenedor interno que tiene el estilo base

        let card; // El div espec√≠fico de la tarjeta (imagen o texto)
        let noteContentElement; // El div que contiene el texto de la nota

        // --- Determinar tipo de tarjeta y crearla ---
        if (notaData.url) { // Tarjeta de Imagen
            card = document.createElement('div');
            card.classList.add('card-wrapper'); // Clase espec√≠fica si se necesita diferenciar

            // Contenedor de la imagen
            const imageContainer = document.createElement('div');
            imageContainer.classList.add('image-container');
            const img = document.createElement('img');
            img.src = notaData.url;
            img.alt = notaData.texto || 'Imagen de la nota';
            img.loading = 'lazy'; // Carga diferida de im√°genes
            // Manejo de error si la imagen no carga
            img.onerror = () => {
                imageContainer.innerHTML = `<div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; background-color:#eee; color:red; text-align:center; padding:10px; font-size:12px;">‚ö†Ô∏è<br/>Error al<br/>cargar imagen</div>`;
                imageContainer.style.height = '100px'; // Reducir altura en error
            }
            imageContainer.appendChild(img);
            card.appendChild(imageContainer);

            // Contenedor para el texto (si existe)
            if (notaData.texto) {
                noteContentElement = document.createElement('div');
                noteContentElement.classList.add('note-content');
                noteContentElement.innerHTML = linkify(notaData.texto); // Usa linkify para URLs
                card.appendChild(noteContentElement);
            }

        } else if (notaData.nota) { // Tarjeta de Texto
            card = document.createElement('div');
            card.classList.add('text-card'); // Clase espec√≠fica si se necesita diferenciar

            // Contenedor del texto
            noteContentElement = document.createElement('div');
            noteContentElement.classList.add('note-content');
            noteContentElement.innerHTML = linkify(notaData.nota); // Usa linkify para URLs
            card.appendChild(noteContentElement);

        } else {
            console.warn(`Nota ${noteId} no tiene 'url' ni 'nota'. No se mostrar√°.`);
            return null; // Si la nota no tiene contenido v√°lido, no la creamos
        }

        // Asegurar que los enlaces en el contenido se abran en nueva pesta√±a
        if (noteContentElement) {
            Array.from(noteContentElement.getElementsByTagName('a')).forEach(link => {
                link.setAttribute('target', '_blank');
                link.setAttribute('rel', 'noopener noreferrer'); // Seguridad para target="_blank"
            });
        }

        // --- Crear Barra de Men√∫ ---
        const menuBar = document.createElement('div');
        menuBar.classList.add('menu-bar'); // Contiene los botones de acci√≥n

        // Bot√≥n Burbuja (para asignar al calendario)
        const bubbleButton = document.createElement('button');
        bubbleButton.classList.add('menu-icon', 'bubble-icon');
        bubbleButton.innerHTML = '‚óè'; // Icono de burbuja
        bubbleButton.setAttribute('draggable', 'true'); // Habilitar arrastre HTML5
        bubbleButton.id = `bubble-${noteId}`;
        bubbleButton.title = "Arrastrar al calendario para asignar fecha";
        // Mostrar solo si la nota NO tiene fecha asignada
        bubbleButton.style.display = notaData.assignedDate ? 'none' : 'inline-block';

        // Evento dragstart para la burbuja
        bubbleButton.addEventListener('dragstart', (e) => {
            // Usar una imagen fantasma transparente para el arrastre
            var imgGhost = new Image();
            imgGhost.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
            e.dataTransfer.setDragImage(imgGhost, 0, 0);
            // Establecer los datos que se transferir√°n (el ID de la nota)
            e.dataTransfer.setData("application/note-id", noteId);
            e.dataTransfer.effectAllowed = "move"; // Indicar que es una operaci√≥n de mover
            openCalendar(); // Abrir el calendario al empezar a arrastrar
        });
        // Tambi√©n abrir calendario al hacer clic (para accesibilidad/alternativa)
        bubbleButton.addEventListener('click', (e) => {
            e.stopPropagation(); // Evitar que el clic se propague
            openCalendar();
        });

        // Contenedor para los botones de editar y eliminar
        const menuActions = document.createElement('div');
        menuActions.classList.add('menu-actions');

        // Bot√≥n Editar
        const editButton = document.createElement('button');
        editButton.classList.add('menu-icon');
        editButton.innerHTML = '‚úé'; // Icono de l√°piz
        editButton.title = "Editar nota";
        editButton.onclick = (e) => {
            e.stopPropagation(); // Evitar propagaci√≥n
            if (typeof iniciarEdicionNota === 'function') {
                iniciarEdicionNota(card, noteId, notaData, menuActions, editButton, deleteButton);
            } else {
                console.error("Funci√≥n iniciarEdicionNota no encontrada.");
            }
        };

        // Bot√≥n Eliminar
        const deleteButton = document.createElement('button');
        deleteButton.classList.add('menu-icon');
        deleteButton.innerHTML = '‚úñ'; // Icono de cruz
        deleteButton.title = "Eliminar nota";
        deleteButton.onclick = (e) => {
            e.stopPropagation(); // Evitar propagaci√≥n
            // A√±adir confirmaci√≥n antes de eliminar
            if (confirm(`¬øEst√°s seguro de que quieres eliminar esta nota?`)) {
                if (typeof eliminarNota === 'function') {
                    eliminarNota(noteId, gridItem); // Pasar el elemento del grid para quitarlo visualmente
                } else {
                    console.error("Funci√≥n eliminarNota no encontrada.");
                    alert("Error interno al intentar eliminar.");
                }
            }
        };

        // A√±adir botones a sus contenedores
        menuActions.appendChild(editButton);
        menuActions.appendChild(deleteButton);
        menuBar.appendChild(bubbleButton); // Burbuja a la izquierda
        menuBar.appendChild(menuActions); // Acciones a la derecha
        card.appendChild(menuBar); // A√±adir barra de men√∫ a la tarjeta

        // Ensamblar el widget
        content.appendChild(card);
        gridItem.appendChild(content);

        // --- Posici√≥n en GridStack ---
        // Usar las coordenadas de Firestore si existen, si no, dejar que GridStack auto-posicione.
        // Establecer un ancho por defecto (w) si no viene de Firestore.
        const position = {
            x: typeof notaData.x === 'number' ? notaData.x : undefined,
            y: typeof notaData.y === 'number' ? notaData.y : undefined,
            w: notaData.w || 6, // Ancho por defecto (ajustar seg√∫n columnas totales)
            // h: notaData.h, // No definimos h, dejamos que se ajuste al contenido
            id: noteId, // Usar el ID de Firestore como ID del widget
            autoPosition: (notaData.x === undefined || notaData.y === undefined) // Auto-posicionar si no hay coords
        };

        // Guardar los datos originales en el elemento para referencia futura (ej: en 'modified')
        gridItem.docData = notaData;

        return { element: gridItem, position: position };
    }

    /**
     * Inicia el modo de edici√≥n para el contenido de una nota.
     * @param {HTMLElement} cardElement - El elemento de la tarjeta que contiene la nota.
     * @param {string} noteId - El ID de la nota en Firestore.
     * @param {object} notaData - Los datos actuales de la nota.
     * @param {HTMLElement} menuActionsContainer - El contenedor de los botones de acci√≥n.
     * @param {HTMLElement} editButton - El bot√≥n de editar original.
     * @param {HTMLElement} deleteButton - El bot√≥n de eliminar original.
     */
    function iniciarEdicionNota(cardElement, noteId, notaData, menuActionsContainer, editButton, deleteButton) {
        // Encontrar el elemento que contiene el texto editable
        let targetElement = cardElement.querySelector('.note-content');
        const isImageNote = !!notaData.url;

        // Si es una nota de imagen SIN texto previo, necesitamos CREAR el div .note-content
        if (isImageNote && !targetElement) {
            targetElement = document.createElement('div');
            targetElement.classList.add('note-content');
            // Insertar el nuevo div antes de la barra de men√∫
            cardElement.insertBefore(targetElement, cardElement.querySelector('.menu-bar'));
        } else if (!targetElement) {
            // Si no es nota de imagen y no encontramos .note-content, algo va mal.
            console.error("Error: No se encontr√≥ .note-content para editar en la nota:", noteId);
            alert("Error al intentar editar la nota.");
            return;
        }

        // Obtener el texto actual
        const currentText = isImageNote ? (notaData.texto || '') : (notaData.nota || '');

        // Reemplazar el contenido actual con un textarea
        targetElement.innerHTML = ''; // Limpiar contenido existente
        const editInput = document.createElement('textarea');
        editInput.value = currentText; // Establecer texto actual
        editInput.style.cssText = `
            width: 100%;
            min-height: 80px;
            height: auto; /* Permitir que crezca */
            box-sizing: border-box;
            border: 1px dashed #ccc;
            padding: 8px;
            resize: vertical;
            font-family: inherit; /* Usar misma fuente */
            font-size: inherit; /* Usar mismo tama√±o */
            line-height: inherit; /* Usar mismo interlineado */
        `;
        targetElement.appendChild(editInput);

        // Ajustar altura inicial y a√±adir listener para auto-redimensionar
        autoResizeTextarea(editInput);
        editInput.addEventListener('input', () => autoResizeTextarea(editInput));
        editInput.focus(); // Poner el foco en el textarea

        // --- Crear botones de Guardar y Cancelar ---
        const saveEditButton = document.createElement('button');
        saveEditButton.classList.add('menu-icon');
        saveEditButton.innerHTML = 'üíæ'; // Icono de guardar
        saveEditButton.title = "Guardar cambios";
        saveEditButton.onclick = (e) => {
            e.stopPropagation();
            const newText = editInput.value.trim(); // Obtener nuevo texto sin espacios extra
            // Determinar qu√© campo actualizar en Firestore
            const updateData = isImageNote ? { texto: newText || firebase.firestore.FieldValue.delete() } // Si est√° vac√≠o, eliminar campo 'texto'
                                         : { nota: newText }; // Actualizar campo 'nota'

            // Validar que no se guarde texto vac√≠o para notas de solo texto
            if (!isImageNote && !newText) {
                alert("La nota de texto no puede estar vac√≠a.");
                editInput.focus();
                return;
            }

            // Deshabilitar bot√≥n mientras se guarda
            saveEditButton.disabled = true;
            saveEditButton.innerHTML = '‚è≥'; // Indicador de carga

            db.collection('notas').doc(noteId).update(updateData)
                .then(() => {
                    console.log(`Nota ${noteId} actualizada correctamente.`);
                    // No es necesario restaurar botones aqu√≠, el listener de Firestore lo har√°
                    // al recibir el evento 'modified'.
                })
                .catch((error) => {
                    console.error('Error al actualizar la nota:', error);
                    alert("Error al guardar los cambios.");
                    // Restaurar botones originales en caso de error
                    targetElement.innerHTML = linkify(currentText); // Restaurar texto original visualmente
                    menuActionsContainer.innerHTML = ''; // Limpiar
                    menuActionsContainer.appendChild(editButton);
                    menuActionsContainer.appendChild(deleteButton);
                });
                // El finally no es necesario aqu√≠ porque Firestore listener se encargar√°
        };

        const cancelEditButton = document.createElement('button');
        cancelEditButton.classList.add('menu-icon');
        cancelEditButton.innerHTML = '‚Ü©Ô∏è'; // Icono de cancelar/deshacer
        cancelEditButton.title = "Cancelar edici√≥n";
        cancelEditButton.onclick = (e) => {
            e.stopPropagation();
            // Restaurar el contenido visual original
            targetElement.innerHTML = linkify(currentText);
            // Restaurar los botones originales
            menuActionsContainer.innerHTML = ''; // Limpiar
            menuActionsContainer.appendChild(editButton);
            menuActionsContainer.appendChild(deleteButton);
        };

        // Reemplazar botones originales con Guardar y Cancelar
        menuActionsContainer.innerHTML = ''; // Limpiar botones actuales
        menuActionsContainer.appendChild(saveEditButton);
        menuActionsContainer.appendChild(cancelEditButton);
    }

    /**
     * Elimina una nota de Firestore y del grid visual.
     * @param {string} noteId - El ID de la nota a eliminar.
     * @param {HTMLElement} gridItemElement - El elemento del DOM correspondiente al widget en GridStack.
     */
    function eliminarNota(noteId, gridItemElement) {
        console.log("Intentando eliminar nota:", noteId);

        // Deshabilitar botones mientras se elimina
        const deleteButton = gridItemElement?.querySelector('.menu-icon[title="Eliminar nota"]');
        if (deleteButton) deleteButton.disabled = true;

        db.collection('notas').doc(noteId).delete()
            .then(() => {
                console.log(`Nota ${noteId} eliminada de Firestore.`);
                // No necesitamos quitar el widget manualmente aqu√≠ si el listener de Firestore
                // est√° activo, ya que √©l recibir√° el evento 'removed' y lo quitar√°.
                // Sin embargo, si queremos una respuesta visual inmediata, podemos hacerlo:
                // if (grid && gridItemElement) {
                //     try {
                //         grid.removeWidget(gridItemElement, false); // false para no notificar de vuelta
                //         console.log(`Widget ${noteId} eliminado visualmente del grid.`);
                //     } catch (removeError) {
                //         console.error(`Error al quitar widget ${noteId} del grid:`, removeError);
                //     }
                // }
                // Limpiar del calendario (esto s√≠ es necesario hacerlo manualmente aqu√≠ o en el listener)
                document.querySelectorAll(`.assigned-bubble[data-note='${noteId}']`).forEach(b => b.remove());
                // Limpiar cach√© si se usa
                delete notesDataCache[noteId];
                // Actualizar cach√© de fechas asignadas si es necesario (m√°s seguro regenerar)
                fetchAllAssignedNotes().then(() => {
                     if(currentCalendarMonth !== undefined) generateCalendar(currentCalendarMonth, currentCalendarYear);
                });

            })
            .catch((error) => {
                console.error("Error al eliminar la nota de Firestore:", error);
                alert("Error al eliminar la nota. Int√©ntalo de nuevo.");
                // Rehabilitar bot√≥n si fall√≥
                if (deleteButton) deleteButton.disabled = false;
            });
    }


    /**************************************************************************
     * Escucha de Cambios en Firestore
     **************************************************************************/

    // Cach√© para datos de notas (clave: noteId, valor: notaData)
    let notesDataCache = {};

    if (db && typeof db.collection === 'function' && grid) {
        db.collection('notas')
          .orderBy('createdAt', 'desc') // Opcional: Ordenar por fecha de creaci√≥n
          .onSnapshot((snapshot) => {
            console.log("Snapshot de Firestore recibido. Cambios:", snapshot.docChanges().length);

            if (!grid) {
                console.error("Error cr√≠tico: GridStack no est√° disponible en onSnapshot.");
                return;
            }

            let needsCalendarUpdate = false; // Bandera para actualizar calendario al final

            snapshot.docChanges().forEach((change) => {
                const noteId = change.doc.id;
                const notaData = change.doc.data();
                const changeType = change.type; // "added", "modified", "removed"

                console.log(`  -> Cambio: Tipo=${changeType}, ID=${noteId}`);

                // Intentar encontrar el widget existente en el grid por su ID
                const widgetElement = grid.engine.nodes.find(n => n.id === noteId)?.el;

                switch (changeType) {
                    case "added":
                        if (!widgetElement) {
                            // Nota nueva a√±adida a Firestore y no existe en el grid
                            console.log(`    A√±adiendo nuevo widget para ${noteId}`);
                            const result = crearWidgetNota(change.doc);
                            if (result) {
                                try {
                                    grid.addWidget(result.element, result.position);
                                    notesDataCache[noteId] = notaData; // A√±adir a cach√©
                                    if (notaData.assignedDate) needsCalendarUpdate = true;
                                } catch (addError) {
                                    console.error(`    Error al a√±adir widget ${noteId} a GridStack:`, addError);
                                }
                            }
                        } else {
                            // La nota ya exist√≠a en el grid (quiz√°s de una carga anterior o un eco)
                            console.log(`    Widget para ${noteId} ya exist√≠a (tipo 'added'), verificando datos.`);
                            // Podr√≠amos forzar una actualizaci√≥n aqu√≠ si sospechamos que los datos pueden ser diferentes
                            // updateWidgetContentAndPosition(widgetElement, notaData, noteId);
                            // Por ahora, asumimos que si ya existe, est√° bien.
                            if (!notesDataCache[noteId]) notesDataCache[noteId] = notaData; // Asegurar cach√©
                            if (notaData.assignedDate && !widgetElement.docData?.assignedDate) needsCalendarUpdate = true; // Si ahora tiene fecha
                             widgetElement.docData = notaData; // Actualizar datos cacheados en el elemento
                        }
                        break;

                    case "modified":
                        if (widgetElement) {
                            // Nota existente modificada en Firestore
                            console.log(`    Modificando widget existente ${noteId}`);
                            const oldData = widgetElement.docData || notesDataCache[noteId] || {}; // Datos previos

                            // Actualizar contenido, posici√≥n y estado de la burbuja
                            updateWidgetContentAndPosition(widgetElement, notaData, noteId, oldData);

                             // Marcar para actualizar calendario si la fecha asignada cambi√≥
                            if (notaData.assignedDate !== oldData.assignedDate) {
                                needsCalendarUpdate = true;
                            }
                            // Actualizar cach√©
                            notesDataCache[noteId] = notaData;
                            widgetElement.docData = notaData; // Actualizar datos en el elemento

                        } else {
                            // Se recibi√≥ 'modified' pero el widget no est√° en el grid.
                            // Podr√≠a ser una nota que se a√±adi√≥ y modific√≥ muy r√°pido antes de renderizarse,
                            // o que fue eliminada localmente pero modificada remotamente.
                            // Podr√≠amos intentar a√±adirla ahora.
                            console.warn(`    Se recibi√≥ 'modified' para ${noteId}, pero no se encontr√≥. Intentando a√±adir...`);
                            const result = crearWidgetNota(change.doc);
                             if (result) {
                                try {
                                    grid.addWidget(result.element, result.position);
                                    notesDataCache[noteId] = notaData;
                                    if (notaData.assignedDate) needsCalendarUpdate = true;
                                } catch (addError) {
                                    console.error(`    Error al a√±adir widget ${noteId} (modificado) a GridStack:`, addError);
                                }
                            }
                        }
                        break;

                    case "removed":
                        if (widgetElement) {
                            // Nota eliminada de Firestore
                            console.log(`    Eliminando widget ${noteId} del grid.`);
                            try {
                                grid.removeWidget(widgetElement, false); // false: no disparar evento 'change' por esto
                                if (notesDataCache[noteId]?.assignedDate) needsCalendarUpdate = true; // Marcar si afecta calendario
                                delete notesDataCache[noteId]; // Limpiar cach√©
                                // Limpiar burbujas del calendario visualmente (redundante si se regenera)
                                document.querySelectorAll(`.assigned-bubble[data-note='${noteId}']`).forEach(b => b.remove());
                            } catch (removeError) {
                                console.error(`    Error al eliminar widget ${noteId} de GridStack:`, removeError);
                            }
                        } else {
                            // Se recibi√≥ 'removed' pero el widget ya no estaba. No hacer nada.
                            console.log(`    Widget ${noteId} (eliminado) no encontrado en el grid.`);
                             delete notesDataCache[noteId]; // Asegurar limpieza de cach√©
                        }
                        break;
                }
            }); // Fin del forEach(change)

            // Actualizar el calendario SI alg√∫n cambio lo requiri√≥ y el calendario est√° visible o se ha mostrado antes
            if (needsCalendarUpdate && currentCalendarMonth !== undefined) {
                console.log("Actualizando calendario debido a cambios detectados...");
                // Recargar todos los datos asignados para asegurar consistencia antes de regenerar
                fetchAllAssignedNotes().then(() => {
                    generateCalendar(currentCalendarMonth, currentCalendarYear);
                });
            } else if (needsCalendarUpdate) {
                 // Si el calendario no est√° visible, solo actualizamos la cach√© de fechas
                 fetchAllAssignedNotes();
            }

          }, (error) => {
            console.error("Error en listener de Firestore:", error);
            alert("Error al sincronizar notas. Por favor, recarga la p√°gina.");
          });
    } else {
        console.error("Firestore (db) o GridStack no inicializados correctamente. El listener no se adjuntar√°.");
        if (!db) alert("Error cr√≠tico: No se pudo conectar a la base de datos.");
        if (!grid) alert("Error cr√≠tico: El √°rea de notas no se pudo inicializar.");
    }

    /**
     * Actualiza el contenido, posici√≥n y estado de la burbuja de un widget existente.
     * Llamada desde el listener de Firestore cuando llega un evento 'modified'.
     * @param {HTMLElement} widgetElement - El elemento del widget en el DOM.
     * @param {object} newData - Los nuevos datos de la nota desde Firestore.
     * @param {string} noteId - El ID de la nota.
     * @param {object} oldData - Los datos anteriores de la nota (cacheados).
     */
    function updateWidgetContentAndPosition(widgetElement, newData, noteId, oldData) {
        // --- 1. Actualizar Contenido (Texto/Imagen) ---
        const noteContentElement = widgetElement.querySelector('.note-content');
        const isImageNote = !!newData.url;
        const newText = isImageNote ? (newData.texto || '') : (newData.nota || '');
        const oldText = isImageNote ? (oldData.texto || '') : (oldData.nota || '');

        // Actualizar texto si cambi√≥ y no est√° en modo edici√≥n
        if (noteContentElement && newText !== oldText && !noteContentElement.querySelector('textarea')) {
            console.log(`      - Actualizando contenido de texto para ${noteId}`);
            noteContentElement.innerHTML = linkify(newText);
            // Re-aplicar target blank a los links
            Array.from(noteContentElement.getElementsByTagName('a')).forEach(link => {
                link.setAttribute('target', '_blank');
                link.setAttribute('rel', 'noopener noreferrer');
            });
        } else if (!noteContentElement && newData.texto && isImageNote) {
            // Si es nota de imagen y AHORA tiene texto pero antes no, crearlo
             console.log(`      - A√±adiendo div de texto para imagen ${noteId}`);
             const newNoteContentElement = document.createElement('div');
             newNoteContentElement.classList.add('note-content');
             newNoteContentElement.innerHTML = linkify(newData.texto);
             widgetElement.querySelector('.card-wrapper').insertBefore(newNoteContentElement, widgetElement.querySelector('.menu-bar'));
             // Re-aplicar target blank
             Array.from(newNoteContentElement.getElementsByTagName('a')).forEach(link => {
                link.setAttribute('target', '_blank');
                link.setAttribute('rel', 'noopener noreferrer');
            });
        } else if (noteContentElement && !newData.texto && isImageNote && oldData.texto) {
             // Si es nota de imagen y AHORA NO tiene texto pero antes s√≠, eliminarlo
             console.log(`      - Eliminando div de texto para imagen ${noteId}`);
             noteContentElement.remove();
        }


        // Actualizar URL de imagen si cambi√≥ (menos com√∫n)
        if (isImageNote && newData.url !== oldData.url) {
            console.log(`      - Actualizando URL de imagen para ${noteId}`);
            const img = widgetElement.querySelector('.image-container img');
            if (img) img.src = newData.url;
        }

        // --- 2. Actualizar Posici√≥n si cambi√≥ en Firestore ---
        // Comparamos la posici√≥n de Firestore (newData.x, newData.y) con la posici√≥n actual del widget en GridStack.
        // Solo actualizamos si son diferentes, para evitar sobrescribir un movimiento local que a√∫n no se ha guardado
        // o que acaba de ser guardado y Firestore nos lo devuelve (eco).
        const currentNode = grid.engine.nodes.find(n => n.id === noteId);
        if (currentNode) {
            const positionChangedInFirestore = (typeof newData.x === 'number' && newData.x !== oldData.x) || (typeof newData.y === 'number' && newData.y !== oldData.y);
            const positionNeedsUpdateLocally = (typeof newData.x === 'number' && newData.x !== currentNode.x) || (typeof newData.y === 'number' && newData.y !== currentNode.y);

            if (positionChangedInFirestore && positionNeedsUpdateLocally) {
                 console.log(`      - Actualizando posici√≥n para ${noteId} desde Firestore a (${newData.x}, ${newData.y}) (Grid actual: ${currentNode.x}, ${currentNode.y})`);
                 try {
                    grid.update(widgetElement, { x: newData.x, y: newData.y });
                 } catch (updateError) {
                     console.error(`      - Error al actualizar posici√≥n de ${noteId} en GridStack:`, updateError);
                 }
            } else if (positionChangedInFirestore) {
                 console.log(`      - Posici√≥n para ${noteId} cambi√≥ en Firestore (${newData.x}, ${newData.y}) pero coincide con GridStack local (${currentNode.x}, ${currentNode.y}). No se actualiza visualmente.`);
            }
        }

        // --- 3. Actualizar estado de la burbuja del calendario ---
        const bubbleButton = widgetElement.querySelector(`#bubble-${noteId}`);
        if (bubbleButton) {
            const shouldDisplayBubble = !newData.assignedDate; // Mostrar si NO tiene fecha
            const isCurrentlyDisplayed = bubbleButton.style.display !== 'none';

            if (shouldDisplayBubble && !isCurrentlyDisplayed) {
                console.log(`      - Mostrando burbuja para ${noteId}`);
                bubbleButton.style.display = 'inline-block';
            } else if (!shouldDisplayBubble && isCurrentlyDisplayed) {
                console.log(`      - Ocultando burbuja para ${noteId}`);
                bubbleButton.style.display = 'none';
            }
        }

        // --- 4. Restaurar botones si estaba en modo edici√≥n ---
        // Si recibimos una actualizaci√≥n de Firestore mientras edit√°bamos,
        // cancelamos la edici√≥n local para reflejar el estado de la base de datos.
        const saveButton = widgetElement.querySelector('.menu-icon[title="Guardar cambios"]');
        if (saveButton) {
             console.log(`      - Cancelando edici√≥n local de ${noteId} debido a modificaci√≥n externa.`);
             const menuActionsContainer = widgetElement.querySelector('.menu-actions');
             const editButtonOriginal = widgetElement.querySelector('.menu-icon[title="Editar nota"]'); // Puede no existir si se recre√≥
             const deleteButtonOriginal = widgetElement.querySelector('.menu-icon[title="Eliminar nota"]'); // Puede no existir

             // Restaurar contenido visual (ya actualizado por el paso 1)
             // Restaurar botones
             if (menuActionsContainer) {
                 menuActionsContainer.innerHTML = ''; // Limpiar (Save/Cancel)
                 // Recrear botones originales si no los encontramos (m√°s seguro)
                 const newEditButton = document.createElement('button');
                 newEditButton.classList.add('menu-icon');
                 newEditButton.innerHTML = '‚úé';
                 newEditButton.title = "Editar nota";
                 newEditButton.onclick = (e) => { e.stopPropagation(); iniciarEdicionNota(widgetElement.querySelector('.card-wrapper') || widgetElement.querySelector('.text-card'), noteId, newData, menuActionsContainer, newEditButton, newDeleteButton); };

                 const newDeleteButton = document.createElement('button');
                 newDeleteButton.classList.add('menu-icon');
                 newDeleteButton.innerHTML = '‚úñ';
                 newDeleteButton.title = "Eliminar nota";
                 newDeleteButton.onclick = (e) => { e.stopPropagation(); if (confirm(`¬øEst√°s seguro de que quieres eliminar esta nota?`)) { eliminarNota(noteId, widgetElement); } };

                 menuActionsContainer.appendChild(newEditButton);
                 menuActionsContainer.appendChild(newDeleteButton);
             }
        }
    }


    /**************************************************************************
     * Manejo de la Interfaz para Agregar Notas (Modales)
     **************************************************************************/
    const addNoteButtonElem = document.getElementById('addNoteButton');
    const addNoteOptionsElem = document.getElementById('addNoteOptions');
    const addImageLinkOptionElem = document.getElementById('addImageLinkOption');
    const addTextNoteOptionElem = document.getElementById('addTextNoteOption');
    const inputAreaElem = document.getElementById('inputArea');
    const imageLinkInputAreaElem = document.getElementById('imageLinkInputArea');
    const imageLinkInputElem = document.getElementById('imageLink');
    // imageNoteTextElem ya definido arriba
    const saveImageLinkButtonElem = document.getElementById('saveImageLink');
    const textNoteInputAreaElem = document.getElementById('textNoteInputArea');
    // textNoteInputElem ya definido arriba
    const saveTextNoteButtonElem = document.getElementById('saveTextNote');
    const blurBackgroundElem = document.querySelector('.blur-background');

    /** Cierra todos los modales y resetea los inputs */
    function hideMenusAndResetForms() {
        if (addNoteOptionsElem) addNoteOptionsElem.style.display = 'none';
        if (inputAreaElem) inputAreaElem.style.display = 'none';
        if (blurBackgroundElem) blurBackgroundElem.style.display = 'none';

        // Resetear inputs
        if (imageLinkInputElem) imageLinkInputElem.value = '';
        if (imageNoteTextElem) { imageNoteTextElem.value = ''; autoResizeTextarea(imageNoteTextElem); }
        if (textNoteInputElem) { textNoteInputElem.value = ''; autoResizeTextarea(textNoteInputElem); }

        // Rehabilitar botones de guardado por si acaso
        if (saveImageLinkButtonElem) saveImageLinkButtonElem.disabled = false;
        if (saveTextNoteButtonElem) saveTextNoteButtonElem.disabled = false;
    }

    /** Muestra el fondo borroso */
    function showBlurBackground() {
        if (blurBackgroundElem) blurBackgroundElem.style.display = 'block';
    }

    // Event Listener para el bot√≥n principal (+)
    if (addNoteButtonElem) {
        addNoteButtonElem.onclick = (e) => {
            e.stopPropagation(); // Evitar que el clic cierre inmediatamente si el fondo est√° activo
            // Si las opciones ya est√°n visibles, oculta todo. Si no, muestra las opciones.
            if (addNoteOptionsElem && addNoteOptionsElem.style.display === 'flex') {
                hideMenusAndResetForms();
            } else if (addNoteOptionsElem) {
                hideMenusAndResetForms(); // Asegura que otros modales est√©n cerrados
                addNoteOptionsElem.style.display = 'flex';
                showBlurBackground();
            }
        };
    }

    // Event Listener para la opci√≥n "Imagen"
    if (addImageLinkOptionElem) {
        addImageLinkOptionElem.onclick = (e) => {
            e.stopPropagation();
            if (addNoteOptionsElem) addNoteOptionsElem.style.display = 'none'; // Ocultar opciones
            if (imageLinkInputAreaElem) imageLinkInputAreaElem.style.display = 'block'; // Mostrar input de imagen
            if (textNoteInputAreaElem) textNoteInputAreaElem.style.display = 'none'; // Ocultar input de texto
            if (inputAreaElem) inputAreaElem.style.display = 'flex'; // Mostrar contenedor de input
            showBlurBackground(); // Asegurar que el fondo est√© visible
            if (imageLinkInputElem) imageLinkInputElem.focus(); // Poner foco en el input de URL
        };
    }

    // Event Listener para la opci√≥n "Nota"
    if (addTextNoteOptionElem) {
        addTextNoteOptionElem.onclick = (e) => {
            e.stopPropagation();
            if (addNoteOptionsElem) addNoteOptionsElem.style.display = 'none'; // Ocultar opciones
            if (imageLinkInputAreaElem) imageLinkInputAreaElem.style.display = 'none'; // Ocultar input de imagen
            if (textNoteInputAreaElem) textNoteInputAreaElem.style.display = 'block'; // Mostrar input de texto
            if (inputAreaElem) inputAreaElem.style.display = 'flex'; // Mostrar contenedor de input
            showBlurBackground(); // Asegurar que el fondo est√© visible
            if (textNoteInputElem) textNoteInputElem.focus(); // Poner foco en el textarea
        };
    }

    // Ev
