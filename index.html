<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Notas Oceánicas - Polaroid</title>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-auth-compat.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@8.3.0/dist/gridstack.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/gridstack@8.3.0/dist/gridstack-all.js"></script>
  <style>
    /* Estilos CSS (sin cambios respecto a tu versión original) */
    .grid-stack-item,
    .grid-stack-item-content,
    .card-wrapper,
    .text-card,
    .note-content {
      box-shadow: none !important;
    }
    .grid-stack-item[data-note-type="imagen"].grid-stack-item-dragging,
    .grid-stack-item[data-note-type="imagen"].grid-stack-item-dragging .grid-stack-item-content {
      opacity: 0.7 !important;
      border: 3px dashed red !important;
      background-color: rgba(255, 0, 0, 0.3) !important;
      box-shadow: none !important;
    }
    .grid-stack-item[data-note-type="texto"].grid-stack-item-dragging,
    .grid-stack-item[data-note-type="texto"].grid-stack-item-dragging .grid-stack-item-content {
      opacity: 0.7 !important;
      border: 3px dashed #a2dff7 !important;
      background-color: rgba(162, 223, 247, 0.3) !important;
      box-shadow: none !important;
    }
    .grid-stack-placeholder {
      display: none !important;
    }
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      overflow: hidden;
      background: linear-gradient(to bottom, #a2dff7 0%, #a2dff7 40%, #03254c 100%);
      font-family: Arial, sans-serif;
    }
    .container {
      height: 100%;
      width: 100%;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }
    #notaDisplay {
      flex-grow: 1;
      width: 100%;
      overflow-y: auto;
      overflow-x: hidden;
      position: relative;
      min-width: 1000px; /* Considera si este min-width es necesario */
    }
    .grid-stack-item {
      transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
      overflow: visible !important;
      margin-bottom: 0px;
    }
    .grid-stack-item-content {
      overflow: visible !important;
      height: auto;
      width: 100%;
      display: flex;
      flex-direction: column;
    }
    .card-wrapper, .text-card {
      background-color: #fff;
      border: 2px solid #0077a3;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      position: relative;
      box-sizing: border-box;
      height: 100%; /* Asegura que la tarjeta ocupe la altura del item */
    }
    .image-container {
      width: 100%;
      /* Altura flexible para imágenes */
      height: auto;
      max-height: 200px; /* Limita altura máxima de la imagen si es necesario */
      overflow: hidden;
      position: relative;
      flex-shrink: 0;
    }
    .image-container img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .note-content {
      background-color: #fff;
      padding: 10px;
      text-align: left;
      font-size: 16px;
      color: #333;
      min-height: 50px;
      box-sizing: border-box;
      word-wrap: break-word;
      overflow: hidden;
      flex-grow: 1; /* Permite que el contenido de texto crezca */
    }
    .note-content a {
      color: #0077a3;
      text-decoration: underline;
    }
    .menu-bar {
      background-color: #0288D1;
      padding: 5px 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      border-top: 1px solid #0077a3;
      border-bottom-left-radius: 6px;
      border-bottom-right-radius: 6px;
      margin-top: auto; /* Empuja la barra al final si la tarjeta es alta */
    }
    .menu-icon {
      background: none;
      border: none;
      font-size: 20px;
      color: #fff;
      cursor: pointer;
      padding: 2px 4px;
    }
    .bubble-icon {
      color: #FFCD05;
      font-size: 22px;
    }
    .menu-actions {
      display: flex;
      gap: 4px;
    }
    #addNoteButton {
      position: absolute;
      bottom: 30px;
      right: 30px;
      background-color: #006994;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      font-size: 30px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      transition: background-color 0.3s ease, transform 0.3s ease;
      z-index: 1001;
    }
    #addNoteButton:hover {
      background-color: #005577;
      transform: scale(1.05);
    }
    #addNoteOptions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.85);
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
      display: none;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      gap: 25px;
      padding: 25px;
      z-index: 1002;
    }
    #addNoteOptions .card {
      background-color: #2c2c2c;
      border: 1px solid #0077a3;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      width: 180px;
    }
    #addNoteOptions .card:hover {
      transform: translateY(-5px) scale(1.03);
      box-shadow: 0 6px 12px rgba(0, 119, 163, 0.5);
    }
    #addNoteOptions .card h2 {
      color: #36a2eb;
      margin-bottom: 10px;
    }
    #addNoteOptions .card p {
      color: #ccc;
      font-size: 14px;
    }
    #inputArea {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #ffffff;
      padding: 25px 30px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      display: none;
      flex-direction: column;
      gap: 15px;
      width: 90%;
      max-width: 550px;
      z-index: 1002;
    }
    #inputArea label {
      font-weight: bold;
      color: #333;
      margin-bottom: 3px;
      font-size: 14px;
    }
    #inputArea textarea, #inputArea input[type="text"] {
      padding: 12px;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
      width: 100%;
      box-sizing: border-box;
      line-height: 1.5;
      font-size: 16px;
    }
    #inputArea textarea {
      min-height: 80px;
    }
    #inputArea textarea#textNote {
      min-height: 120px;
    }
    #inputArea button {
      padding: 10px 20px;
      background-color: #006994;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.1s ease;
      align-self: flex-end;
      margin-top: 10px;
      font-size: 16px;
      font-weight: bold;
    }
    #inputArea button:hover {
      background-color: #005577;
    }
    #inputArea button:active {
      transform: scale(0.98);
    }
    .input-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .calendar-icon {
      position: absolute;
      bottom: 30px;
      left: 30px;
      width: 45px;
      height: 45px;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: #333;
      font-size: 24px;
      cursor: pointer;
      z-index: 1001;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    }
    .calendar-widget {
      position: absolute;
      bottom: 85px;
      left: 20px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      padding: 15px;
      display: none;
      z-index: 1001;
      width: 320px;
      min-height: 300px;
    }
    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    .calendar-header button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 20px;
      color: #0077a3;
      padding: 5px 8px;
      border-radius: 4px;
      transition: background-color 0.2s ease;
    }
    .calendar-header button:hover:not(:disabled) {
      background-color: #e0f7fa;
    }
    .calendar-header button:disabled {
      color: #ccc;
      cursor: default;
    }
    .calendar-header span {
      font-weight: bold;
      color: #333;
      font-size: 18px;
    }
    .calendar-days-header, .calendar-dates-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      text-align: center;
      gap: 6px;
    }
    .calendar-days-header {
      margin-bottom: 10px;
      font-weight: bold;
      color: #555;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
      font-size: 13px;
    }
    .calendar-day {
      padding: 3px;
    }
    .calendar-date {
      padding: 0;
      border-radius: 50%;
      color: #333;
      border: 2px solid transparent;
      cursor: pointer;
      position: relative;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
      line-height: 1;
      font-size: 14px;
      transition: background-color 0.2s ease, border-color 0.2s ease;
    }
    .calendar-date.empty {
      background: none;
      cursor: default;
      opacity: 0;
    }
    .calendar-date:not(.empty):hover {
      background-color: #e0f7fa;
      border-color: #b3e5fc;
    }
    .calendar-date.today {
      border-color: #0077a3;
      font-weight: bold;
      color: #005577;
    }
    .calendar-date.drag-over {
      background-color: #a2dff7 !important;
      border-color: #0077a3 !important;
    }
    .assigned-bubble {
      color: #FFCD05;
      font-size: 11px;
      position: absolute;
      bottom: 3px;
      left: 50%;
      transform: translateX(-50%);
      line-height: 1;
      text-shadow: 0 0 1px rgba(0, 0, 0, 0.5);
      pointer-events: none;
    }
    .calendar-date .assigned-bubble + .assigned-bubble {
      bottom: -2px;
    }
    .blur-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      display: none;
      z-index: 1000;
      cursor: pointer;
    }
    @media (max-width: 575.98px) {
      #inputArea {
        width: 95%;
      }
      #addNoteOptions {
        flex-direction: column;
        gap: 15px;
        padding: 20px;
      }
      #addNoteOptions .card {
        width: 150px;
      }
    }
    @media (max-width: 576px) {
      /* Puedes añadir estilos específicos para pantallas muy pequeñas aquí si es necesario */
    }
  </style>
</head>
<body>
  <div id="auth-section" style="padding: 15px; background-color: #f0f0f0; border-bottom: 1px solid #ccc; text-align: center; margin-bottom: 10px;">
    <div id="login-form">
      <input type="email" id="login-email" placeholder="Correo" style="padding: 8px; margin-right: 5px;">
      <input type="password" id="login-password" placeholder="Contraseña" style="padding: 8px; margin-right: 5px;">
      <button id="login-button" style="padding: 8px 12px;">Entrar</button>
    </div>
    <div id="user-info" style="display: none;">
      <span>Conectado como: <strong id="user-email-display"></strong></span>
      <button id="logout-button" style="padding: 8px 12px; margin-left: 15px;">Salir</button>
    </div>
  </div>

  <div class="container">
    <div id="notaDisplay" class="grid-stack"></div>
    <button id="addNoteButton" title="Añadir nueva nota o imagen">+</button>
    <div id="addNoteOptions">
      <div class="card" id="addImageLinkOption" title="Añadir una nota con imagen desde un enlace web">
        <h2>🖼️ Imagen</h2>
        <p>Guardar link de imagen.</p>
      </div>
      <div class="card" id="addTextNoteOption" title="Añadir una nota de texto simple">
        <h2>📝 Nota</h2>
        <p>Subir nota de texto.</p>
      </div>
    </div>
    <div id="inputArea">
      <div id="imageLinkInputArea" style="display: none;">
        <div class="input-group">
          <label for="imageLink">Link de la imagen:</label>
          <input type="text" id="imageLink" placeholder="Pega aquí la URL de la imagen (ej: https://...)" />
        </div>
        <div class="input-group">
          <label for="imageNoteText">Texto adicional (opcional):</label>
          <textarea id="imageNoteText" placeholder="Escribe aquí una descripción o nota relacionada con la imagen..." rows="3"></textarea>
        </div>
        <button id="saveImageLink">Guardar Imagen</button>
      </div>
      <div id="textNoteInputArea" style="display: none;">
        <div class="input-group">
          <label for="textNote">Nota:</label>
          <textarea id="textNote" placeholder="Escribe tu nota aquí..." rows="5"></textarea>
        </div>
        <button id="saveTextNote">Guardar Nota</button>
      </div>
    </div>
    <div id="calendarIcon" class="calendar-icon" title="Mostrar/Ocultar Calendario">📅</div>
    <div id="calendarWidget" class="calendar-widget"></div>
    <div class="blur-background"></div>
  </div>

  <script>
    // --- Funciones Utilitarias ---
    function linkify(text) {
      if (!text) return "";
      const urlRegex = /(?<!href=["'])(https?:\/\/[^\s<>"']+)/g;
      const replacedText = text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
      return replacedText.replace(/\n/g, '<br>');
    }

    function autoResizeTextarea(el) {
      if (!el) return;
      el.style.height = 'auto';
      el.style.height = (el.scrollHeight + 2) + 'px';
    }

    // --- Configuración de Firebase ---
    const firebaseConfig = {
      apiKey: "AIzaSyCHa373WgLLHsy8wZXK9zr_HVieQvlrhUs", // Considera proteger esta clave en producción
      authDomain: "oasis-b036d.firebaseapp.com",
      projectId: "oasis-b036d",
      storageBucket: "oasis-b036d.appspot.com",
      messagingSenderId: "141546637821",
      appId: "1:141546637821:web:0a861aeb13831774ed3194",
      measurementId: "G-HB2P17H5YL"
    };

    try {
      firebase.initializeApp(firebaseConfig);
    } catch (e) {
      console.error("Error inicializando Firebase:", e);
      alert("Error crítico: No se pudo inicializar la conexión a la base de datos.");
    }

    const db = firebase.firestore();
    const auth = firebase.auth();

    // --- Variables Globales y Configuración de Gridstack ---
    let grid;
    try {
      grid = GridStack.init({
        column: 12,
        margin: 5,
        cellHeight: 'auto', // Altura automática basada en contenido
        disableResize: true, // Deshabilita redimensionar notas
        float: true, // Permite que los elementos floten
        overlap: false, // No permite superposición
        animate: true, // Anima movimientos
        alwaysShowResizeHandle: false,
        draggable: {
          handle: '.menu-bar', // Solo se puede arrastrar desde la barra de menú
          scroll: true,
          appendTo: 'body' // Evita problemas de z-index al arrastrar
        }
      });
    } catch (e) {
      console.error("Error inicializando GridStack:", e);
      alert("Error crítico: No se pudo inicializar el área de notas.");
    }

    // --- Variables y Lógica para Responsividad del Grid ---
    const gridStackElement = document.getElementById('notaDisplay');
    let currentColumnCount = 12;
    const breakpoints = [
      { width: 992, cols: 12 },
      { width: 576, cols: 6 },
      { width: 0, cols: 3 }
    ];

    function adjustGridColumns() {
      const screenWidth = window.innerWidth;
      let newColumnCount = 12;
      for (const bp of breakpoints) {
        if (screenWidth >= bp.width) {
          newColumnCount = bp.cols;
          break;
        }
      }
      if (newColumnCount !== currentColumnCount) {
        if (grid) {
          grid.column(newColumnCount, true); // Ajusta columnas y redibuja
        }
        currentColumnCount = newColumnCount;
        console.log("Grid ajustado a", newColumnCount, "columnas");
      }
    }

    adjustGridColumns(); // Ajusta al cargar
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(adjustGridColumns, 150); // Espera un poco antes de ajustar al redimensionar
    });

    // --- Eventos de Gridstack para Guardar Posición ---
    if (grid) {
      grid.on('change', function (event, items) {
        console.log("GridStack 'change' event:", items.length, "items changed/moved");
        items.forEach(function (item) {
          const noteIdToSave = item.el?.getAttribute('data-note-id');
          // Guarda solo si es un item válido con ID y coordenadas numéricas
          if (noteIdToSave && typeof item.x === 'number' && typeof item.y === 'number') {
            console.log(`   -> Guardando posición para ${noteIdToSave}: x=${item.x}, y=${item.y}`);
            db.collection('notas').doc(noteIdToSave).update({
              x: item.x,
              y: item.y
            }).catch(err => console.error(`Error guardando posición (${noteIdToSave}) desde 'change': ${err.message}`));
          }
        });
      });

      // Opcional: Log al soltar (dragstop)
      grid.on('dragstop', function (event, element) {
        const node = grid.engine.nodes.find(n => n.el === element);
        if (node) {
          const noteId = node.el?.getAttribute('data-note-id') || node.id || '(desconocido)';
          console.log(`GridStack 'dragstop': Nota ID: ${noteId} soltada en x=${node.x}, y=${node.y}`);
        }
      });
    } else {
        console.error("Grid no fue inicializado, los eventos de grid no se adjuntarán.");
    }

    // --- Referencias a Elementos del DOM ---
    const gridContainer = document.getElementById('notaDisplay');
    const textNoteInputElem = document.getElementById('textNote');
    const imageNoteTextElem = document.getElementById('imageNoteText');
    const addNoteButtonElem = document.getElementById('addNoteButton');
    const addNoteOptionsElem = document.getElementById('addNoteOptions');
    const addImageLinkOptionElem = document.getElementById('addImageLinkOption');
    const addTextNoteOptionElem = document.getElementById('addTextNoteOption');
    const inputAreaElem = document.getElementById('inputArea');
    const imageLinkInputAreaElem = document.getElementById('imageLinkInputArea');
    const imageLinkInputElem = document.getElementById('imageLink');
    const saveImageLinkButtonElem = document.getElementById('saveImageLink');
    const textNoteInputAreaElem = document.getElementById('textNoteInputArea');
    const saveTextNoteButtonElem = document.getElementById('saveTextNote');
    const blurBackgroundElem = document.querySelector('.blur-background');
    const calendarIconElem = document.getElementById('calendarIcon');
    const calendarWidgetElem = document.getElementById('calendarWidget');
    // Referencias para Auth UI
    const loginFormDiv = document.getElementById('login-form');
    const userInfoDiv = document.getElementById('user-info');
    const userEmailDisplay = document.getElementById('user-email-display');
    const loginButton = document.getElementById('login-button');
    const logoutButton = document.getElementById('logout-button');
    const emailInput = document.getElementById('login-email');
    const passwordInput = document.getElementById('login-password');

    // --- Variables Globales para Estado ---
    const displayedNotes = new Map(); // Para llevar registro de qué notas están en el grid
    let currentCalendarMonth, currentCalendarYear;
    let assignedDatesCache = {};
    let notesDataCache = {}; // Cache para datos de notas (útil para calendario)
    let calendarTimeout;
    let unsubscribeFirestore = null; // MUY IMPORTANTE para detener el listener al cerrar sesión

    // --- Listener para auto-resize de textareas ---
    if (textNoteInputElem) textNoteInputElem.addEventListener('input', () => autoResizeTextarea(textNoteInputElem));
    if (imageNoteTextElem) imageNoteTextElem.addEventListener('input', () => autoResizeTextarea(imageNoteTextElem));

    // --- Función para Crear/Actualizar Notas en el Grid ---
    function mostrarNotaEnPantalla(doc) {
      const notaData = doc.data();
      const noteId = doc.id;

      // Crea el elemento principal del grid item
      let gridItem = document.createElement('div');
      gridItem.classList.add('grid-stack-item');
      gridItem.setAttribute('data-note-id', noteId);
      gridItem.setAttribute('data-note-type', notaData.tipo);

      // Crea el contenedor interno del contenido
      const content = document.createElement('div');
      content.classList.add('grid-stack-item-content');

      let card; // Contenedor de la tarjeta (imagen o texto)
      let noteContentElement = null; // Elemento para el texto (si existe)

      // --- Lógica para crear tarjeta de IMAGEN ---
      if (notaData.url) {
        card = document.createElement('div');
        card.classList.add('card-wrapper');

        const imageContainer = document.createElement('div');
        imageContainer.classList.add('image-container');
        const img = document.createElement('img');
        img.src = notaData.url;
        img.alt = notaData.texto || 'Imagen de la nota';
        img.loading = 'lazy'; // Carga diferida de imágenes
        img.onerror = () => { // Manejo de error si la imagen no carga
          imageContainer.innerHTML = `<div style="display:flex; align-items:center; justify-content:center; height:100%; background-color:#eee; color:red; text-align:center; padding:10px;">⚠️<br/>Error al<br/>cargar imagen</div>`;
        };
        imageContainer.appendChild(img);
        card.appendChild(imageContainer);

        // Si hay texto adicional, añadirlo
        if (notaData.texto) {
          noteContentElement = document.createElement('div');
          noteContentElement.classList.add('note-content');
          noteContentElement.innerHTML = linkify(notaData.texto); // Convierte URLs a links
          card.appendChild(noteContentElement);
        }
      // --- Lógica para crear tarjeta de TEXTO ---
      } else if (notaData.nota) {
        card = document.createElement('div');
        card.classList.add('text-card');

        noteContentElement = document.createElement('div');
        noteContentElement.classList.add('note-content');
        noteContentElement.innerHTML = linkify(notaData.nota); // Convierte URLs a links
        card.appendChild(noteContentElement);
      } else {
        // Si la nota no tiene ni URL ni texto, no la mostramos
        console.warn("Nota sin contenido válido:", noteId);
        return null;
      }

      // Asegura que los links en el contenido abran en nueva pestaña
      if (noteContentElement) {
        Array.from(noteContentElement.getElementsByTagName('a')).forEach(link => {
          link.setAttribute('target', '_blank');
          link.setAttribute('rel', 'noopener noreferrer');
        }); // <-- ¡¡CORREGIDO!! Asegúrate que esta línea termine con });
      }

      // --- Barra de Menú Inferior ---
      const menuBar = document.createElement('div');
      menuBar.classList.add('menu-bar');

      // Botón Burbuja (para calendario)
      const bubbleButton = document.createElement('button');
      bubbleButton.classList.add('menu-icon', 'bubble-icon');
      bubbleButton.innerHTML = '●';
      bubbleButton.setAttribute('draggable', 'true');
      bubbleButton.id = `bubble-${noteId}`;
      bubbleButton.title = "Arrastrar al calendario";
      bubbleButton.style.display = notaData.assignedDate ? 'none' : 'inline-block'; // Oculta si ya tiene fecha
      bubbleButton.addEventListener('dragstart', (e) => {
        // Configura datos para arrastrar y soltar
        var imgGhost = new Image(); // Imagen fantasma transparente
        imgGhost.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
        e.dataTransfer.setDragImage(imgGhost, 0, 0);
        e.dataTransfer.setData("application/note-id", noteId); // Pasa el ID de la nota
        e.dataTransfer.effectAllowed = "move";
        if (typeof openCalendar === 'function') openCalendar(); // Abre el calendario al arrastrar
      });
      bubbleButton.addEventListener('click', (e) => {
        e.stopPropagation(); // Evita que el click se propague
        if (typeof openCalendar === 'function') openCalendar();
      });

      // Acciones (Editar, Eliminar)
      const menuActions = document.createElement('div');
      menuActions.classList.add('menu-actions');

      const editButton = document.createElement('button');
      editButton.classList.add('menu-icon');
      editButton.innerHTML = '✎';
      editButton.title = "Editar";

      const deleteButton = document.createElement('button');
      deleteButton.classList.add('menu-icon');
      deleteButton.innerHTML = '✖';
      deleteButton.title = "Eliminar";

      // Funcionalidad de los botones (se asigna aquí para tener acceso a las variables)
      deleteButton.onclick = (e) => {
        e.stopPropagation();
        if (typeof deleteNote === 'function') {
          // Pide confirmación antes de borrar
          if (confirm(`¿Seguro que quieres eliminar esta nota?`)) {
            deleteNote(noteId, gridItem);
          }
        } else {
          console.error("Función deleteNote no encontrada");
          alert("Error interno al eliminar.");
        }
      };
      editButton.onclick = (e) => {
        e.stopPropagation();
        if (typeof editNoteContent === 'function') {
          editNoteContent(card, noteId, notaData, menuActions, editButton, deleteButton);
        } else {
          console.error("Función editNoteContent no encontrada");
        }
      };

      menuActions.appendChild(editButton);
      menuActions.appendChild(deleteButton);
      menuBar.appendChild(bubbleButton);
      menuBar.appendChild(menuActions);
      card.appendChild(menuBar); // Añade la barra a la tarjeta

      // Ensambla el grid item
      content.appendChild(card);
      gridItem.appendChild(content);

      // Define la posición y tamaño para Gridstack
      const pos = {
        x: notaData.x, // Usa las coordenadas guardadas si existen
        y: notaData.y,
        w: notaData.w || 2, // Ancho por defecto si no está guardado
        h: notaData.h || 'auto', // Altura automática si no está guardada
        id: noteId, // Usa el ID de Firestore como ID del widget
        autoPosition: (notaData.x === undefined || notaData.y === undefined) // Deja que Gridstack posicione si no hay coords
      };

      gridItem.docData = notaData; // Guarda los datos de la nota en el elemento DOM

      return {
        element: gridItem,
        position: pos
      };
    } // --- Fin de mostrarNotaEnPantalla ---

    // --- Función para Editar Contenido de Notas ---
    function editNoteContent(card, noteId, notaData, menuActionsContainer, editButton, deleteButton) {
      let targetElement = card.querySelector('.note-content');
      // Si es una nota de imagen SIN texto previo, crea el div para el texto
      if (!targetElement && notaData.url) {
        targetElement = document.createElement('div');
        targetElement.classList.add('note-content');
        card.insertBefore(targetElement, card.querySelector('.menu-bar')); // Inserta antes de la barra
      } else if (!targetElement && !notaData.url) {
        // Esto no debería pasar si la nota de texto se creó bien, pero por si acaso
        console.error("Error: No se encontró .note-content para editar texto en nota:", noteId);
        return;
      }

      const isImageNote = !!notaData.url;
      const currentText = isImageNote ? (notaData.texto || '') : (notaData.nota || '');

      // Reemplaza el contenido actual con un textarea para editar
      targetElement.innerHTML = ''; // Limpia el div
      const editInput = document.createElement('textarea');
      editInput.value = currentText;
      editInput.style.cssText = "width:100%; min-height:80px; height:auto; box-sizing:border-box; border:1px dashed #ccc; resize:vertical; margin-bottom: 5px;"; // Estilo básico
      targetElement.appendChild(editInput);
      autoResizeTextarea(editInput); // Ajusta altura inicial
      editInput.addEventListener('input', () => autoResizeTextarea(editInput)); // Ajusta al escribir
      editInput.focus(); // Pone el cursor en el textarea

      // Crea y configura el botón de Guardar edición
      const saveEditButton = document.createElement('button');
      saveEditButton.classList.add('menu-icon');
      saveEditButton.innerHTML = '💾';
      saveEditButton.title = "Guardar Cambios";
      saveEditButton.onclick = (e) => {
        e.stopPropagation();
        const newText = editInput.value.trim();
        // Prepara el objeto de actualización para Firestore
        const updateData = isImageNote ? { texto: newText || firebase.firestore.FieldValue.delete() } : { nota: newText }; // Si el texto se borra, elimina el campo 'texto' en notas de imagen
        if (!isImageNote && !newText) {
            alert("La nota de texto no puede quedar vacía. Si quieres borrarla, usa el botón '✖'.");
            return;
        }

        saveEditButton.disabled = true; // Deshabilita mientras guarda
        saveEditButton.innerHTML = '⏳'; // Indica que está guardando

        db.collection('notas').doc(noteId).update(updateData)
          .then(() => {
            console.log("Nota actualizada:", noteId);
            // No es necesario reemplazar botones aquí, onSnapshot actualizará la UI
          })
          .catch((error) => {
            console.error('Error al actualizar nota:', error);
            alert("Error al guardar los cambios.");
            // Reactiva el botón si falla
            saveEditButton.disabled = false;
            saveEditButton.innerHTML = '💾';
            // Considera restaurar los botones originales si el guardado falla persistentemente
            // menuActionsContainer.innerHTML = '';
            // menuActionsContainer.appendChild(editButton);
            // menuActionsContainer.appendChild(deleteButton);
          });
      };

      // Reemplaza los botones Editar/Eliminar por el botón Guardar
      menuActionsContainer.innerHTML = ''; // Limpia acciones actuales
      menuActionsContainer.appendChild(saveEditButton);
    } // --- Fin de editNoteContent ---

    // --- Función para Eliminar Notas ---
    function deleteNote(noteId, gridItem) {
      console.log("Intentando eliminar nota:", noteId);
      db.collection('notas').doc(noteId).delete()
        .then(() => {
          console.log(`Nota ${noteId} eliminada de Firestore.`);
          // El listener onSnapshot se encargará de quitarla del grid
        })
        .catch((error) => {
          console.error("Error al eliminar nota de Firestore:", error);
          alert("Error al eliminar la nota.");
        });
    } // --- Fin de deleteNote ---

    // --- Funciones para Mostrar/Ocultar Menús y Popups ---
    function hideMenus() {
      if (addNoteOptionsElem) addNoteOptionsElem.style.display = 'none';
      if (inputAreaElem) inputAreaElem.style.display = 'none';
      if (blurBackgroundElem) blurBackgroundElem.style.display = 'none';
      // Limpia los inputs al cerrar
      if (imageLinkInputElem) imageLinkInputElem.value = '';
      if (imageNoteTextElem) {
        imageNoteTextElem.value = '';
        autoResizeTextarea(imageNoteTextElem); // Resetea altura
      }
      if (textNoteInputElem) {
        textNoteInputElem.value = '';
        autoResizeTextarea(textNoteInputElem); // Resetea altura
      }
    }

    // --- Listeners para Botones de UI (Añadir Nota, etc.) ---
    if (addNoteButtonElem) {
      addNoteButtonElem.onclick = (e) => {
        e.stopPropagation();
        if (addNoteOptionsElem && addNoteOptionsElem.style.display === 'flex') {
          hideMenus();
        } else if (addNoteOptionsElem && blurBackgroundElem) {
          hideMenus(); // Cierra otros popups si estuvieran abiertos
          addNoteOptionsElem.style.display = 'flex';
          blurBackgroundElem.style.display = 'block';
        }
      };
    }

    if (addImageLinkOptionElem) {
      addImageLinkOptionElem.onclick = (e) => {
        e.stopPropagation();
        if (addNoteOptionsElem) addNoteOptionsElem.style.display = 'none'; // Oculta opciones
        if (imageLinkInputAreaElem) imageLinkInputAreaElem.style.display = 'block'; // Muestra input imagen
        if (textNoteInputAreaElem) textNoteInputAreaElem.style.display = 'none';
        if (inputAreaElem) inputAreaElem.style.display = 'flex'; // Muestra popup general
        if (blurBackgroundElem) blurBackgroundElem.style.display = 'block'; // Muestra fondo borroso
        if (imageLinkInputElem) imageLinkInputElem.focus(); // Pone foco en input
      };
    }

    if (addTextNoteOptionElem) {
      addTextNoteOptionElem.onclick = (e) => {
        e.stopPropagation();
        if (addNoteOptionsElem) addNoteOptionsElem.style.display = 'none';
        if (imageLinkInputAreaElem) imageLinkInputAreaElem.style.display = 'none';
        if (textNoteInputAreaElem) textNoteInputAreaElem.style.display = 'block';
        if (inputAreaElem) inputAreaElem.style.display = 'flex';
        if (blurBackgroundElem) blurBackgroundElem.style.display = 'block';
        if (textNoteInputElem) textNoteInputElem.focus();
      };
    }

    if (blurBackgroundElem) {
      blurBackgroundElem.onclick = hideMenus; // Cierra popups al hacer click fuera
    }

    // --- Funciones para Guardar Nuevas Notas ---
    function guardarLinkDeImagen() {
      if (!imageLinkInputElem || !db) return;
      let link = imageLinkInputElem.value.trim();
      const texto = imageNoteTextElem ? imageNoteTextElem.value.trim() : '';

      // Validación simple de URL
      if (link && (link.startsWith('http://') || link.startsWith('https://'))) {
        if (saveImageLinkButtonElem) saveImageLinkButtonElem.disabled = true;
        db.collection('notas').add({
          url: link,
          texto: texto || null, // Guarda null si no hay texto
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          tipo: 'imagen',
          w: 2, // Tamaño inicial por defecto para imágenes
          h: 'auto' // Altura automática
        }).then(() => {
          console.log("Imagen guardada.");
          hideMenus();
        }).catch((error) => {
          console.error('Error al guardar link:', error);
          alert("Error al guardar imagen: " + error.message);
        }).finally(() => {
          if (saveImageLinkButtonElem) saveImageLinkButtonElem.disabled = false;
        });
      } else {
        alert("Introduce un link válido (que empiece con http:// o https://).");
        imageLinkInputElem.focus();
      }
    }

    function guardarNotaTexto() {
      if (!textNoteInputElem || !db) return;
      const nota = textNoteInputElem.value.trim();
      if (nota) { // Solo guarda si hay texto
        if (saveTextNoteButtonElem) saveTextNoteButtonElem.disabled = true;
        db.collection('notas').add({
          nota: nota,
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          tipo: 'texto',
          w: 2, // Tamaño inicial por defecto
          h: 'auto'
        }).then(() => {
          console.log("Nota de texto guardada.");
          hideMenus();
        }).catch((error) => {
          console.error('Error al guardar nota:', error);
          alert("Error al guardar nota: " + error.message);
        }).finally(() => {
          if (saveTextNoteButtonElem) saveTextNoteButtonElem.disabled = false;
        });
      } else {
        alert("Escribe algo en la nota.");
        textNoteInputElem.focus();
      }
    }

    // Asigna las funciones a los botones de guardar
    if (saveImageLinkButtonElem) saveImageLinkButtonElem.onclick = guardarLinkDeImagen;
    if (saveTextNoteButtonElem) saveTextNoteButtonElem.onclick = guardarNotaTexto;

    // --- Lógica del Calendario ---
    function getChileDate() {
      try {
        // Intenta obtener la hora de Chile
        const opts = { timeZone: 'America/Santiago', year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: false };
        const fmt = new Intl.DateTimeFormat('en-CA', opts); // Formato YYYY-MM-DD
        const p = fmt.formatToParts(new Date());
        const d = {};
        p.forEach(({ type, value }) => d[type] = parseInt(value, 10));
        // Crea la fecha usando UTC para evitar problemas de zona horaria del navegador
        return new Date(Date.UTC(d.year, d.month - 1, d.day, d.hour, d.minute, d.second));
      } catch (e) {
        // Si falla Intl (navegadores viejos), usa la hora local como fallback
        console.warn("Intl timezone fallback, usando hora local.", e);
        return new Date();
      }
    }

    function initCalendarDate() {
      let today = getChileDate();
      let year = today.getFullYear();
      let month = today.getMonth(); // 0 = Enero, 11 = Diciembre
      // Opcional: poner límites si es necesario
      // const minY = 2024;
      // const minM = 0; // Enero
      // if (year < minY || (year === minY && month < minM)) {
      //   return { month: minM, year: minY };
      // }
      return { month, year };
    }

    function getMonthName(idx) {
      const months = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
      return months[idx] || ''; // idx va de 0 a 11
    }

    async function fetchAllAssignedNotes() {
      console.log("Fetching assigned notes...");
      assignedDatesCache = {}; // Limpia caché de fechas asignadas
      // No limpiamos notesDataCache aquí, ya que puede contener notas no asignadas
      try {
        // Busca todas las notas que tengan el campo 'assignedDate'
        const snap = await db.collection('notas').where('assignedDate', '!=', null).get();
        snap.forEach(doc => {
          const d = doc.data();
          const id = doc.id;
          // Asegura que la nota esté en el caché general
          if (!notesDataCache[id]) {
              notesDataCache[id] = d;
          }
          const dateStr = d.assignedDate; // Formato "D/M/YYYY"
          if (dateStr) {
            if (!assignedDatesCache[dateStr]) assignedDatesCache[dateStr] = [];
            // Evita duplicados en la lista de IDs para una fecha
            if (!assignedDatesCache[dateStr].includes(id)) {
              assignedDatesCache[dateStr].push(id);
            }
          }
        });
        console.log("Assigned dates cache updated:", assignedDatesCache);
      } catch (err) {
        console.error("Error fetching assigned notes:", err);
        // Considera mostrar un error al usuario si la carga falla
      }
    }

    async function generateCalendar(month, year) {
      // Si no hay datos de notas asignadas, los busca primero
      if (Object.keys(assignedDatesCache).length === 0) {
          await fetchAllAssignedNotes();
      }

      if (!calendarWidgetElem) return;
      calendarWidgetElem.innerHTML = ''; // Limpia calendario anterior

      const today = getChileDate(); // Obtiene fecha actual (considerando zona horaria)
      const currentMonth = today.getMonth();
      const currentYear = today.getFullYear();
      const currentDate = today.getDate();

      // --- Cabecera del Calendario (Mes, Año, Botones) ---
      const hdr = document.createElement('div');
      hdr.className = 'calendar-header';
      const pBtn = document.createElement('button');
      pBtn.innerHTML = '&lt;';
      pBtn.title = "Mes Anterior";
      // Lógica para deshabilitar botón si se llega a un límite (opcional)
      // const minY = 2024; const minM = 0;
      // if (year === minY && month === minM) pBtn.disabled = true;
      pBtn.onclick = () => generateCalendar(month === 0 ? 11 : month - 1, month === 0 ? year - 1 : year);

      const nBtn = document.createElement('button');
      nBtn.innerHTML = '&gt;';
      nBtn.title = "Mes Siguiente";
      nBtn.onclick = () => generateCalendar(month === 11 ? 0 : month + 1, month === 11 ? year + 1 : year);

      const title = document.createElement('span');
      title.textContent = `${getMonthName(month)} ${year}`;

      hdr.appendChild(pBtn);
      hdr.appendChild(title);
      hdr.appendChild(nBtn);
      calendarWidgetElem.appendChild(hdr);

      // --- Cabecera de Días de la Semana ---
      const daysHdr = document.createElement('div');
      daysHdr.className = 'calendar-days-header';
      ['Do', 'Lu', 'Ma', 'Mi', 'Ju', 'Vi', 'Sá'].forEach(day => {
        const d = document.createElement('div');
        d.className = 'calendar-day';
        d.textContent = day;
        daysHdr.appendChild(d);
      });
      calendarWidgetElem.appendChild(daysHdr);

      // --- Cuadrícula de Fechas ---
      const datesG = document.createElement('div');
      datesG.className = 'calendar-dates-grid';
      const firstDayOfMonth = new Date(year, month, 1).getDay(); // 0=Domingo, 1=Lunes...
      const daysInMonth = new Date(year, month + 1, 0).getDate(); // Último día del mes actual

      // Celdas vacías antes del primer día
      for (let i = 0; i < firstDayOfMonth; i++) {
        const e = document.createElement('div');
        e.className = 'calendar-date empty';
        datesG.appendChild(e);
      }

      // Celdas para cada día del mes
      for (let date = 1; date <= daysInMonth; date++) {
        const cell = document.createElement('div');
        cell.className = 'calendar-date';
        cell.textContent = date;
        const dateString = `${date}/${month + 1}/${year}`; // Formato D/M/YYYY

        // Marca el día de hoy
        if (date === currentDate && month === currentMonth && year === currentYear) {
          cell.classList.add('today');
        }

        // Añade burbujas si hay notas asignadas a esta fecha
        if (assignedDatesCache[dateString]) {
          assignedDatesCache[dateString].forEach(noteId => {
            const bubble = document.createElement("span");
            bubble.className = "assigned-bubble";
            bubble.setAttribute("data-note", noteId);
            bubble.textContent = "●";
            // Opcional: Añadir tooltip con info de la nota
            // const noteInfo = notesDataCache[noteId];
            // if(noteInfo) bubble.title = noteInfo.nota || noteInfo.texto || noteId;
            cell.appendChild(bubble);
          });
        }

        // --- Eventos Drag & Drop para asignar notas ---
        cell.addEventListener('dragover', (e) => {
          e.preventDefault(); // Necesario para permitir drop
          e.dataTransfer.dropEffect = "move";
          cell.classList.add('drag-over'); // Resaltado visual
        });
        cell.addEventListener('dragleave', () => {
          cell.classList.remove('drag-over'); // Quita resaltado
        });
        cell.addEventListener('drop', async (e) => {
          e.preventDefault();
          cell.classList.remove('drag-over');
          const noteId = e.dataTransfer.getData("application/note-id");
          if (noteId) {
            console.log(`Nota ${noteId} soltada en fecha ${dateString}`);
            const oldDateStr = notesDataCache[noteId]?.assignedDate;

            try {
              // Actualiza la nota en Firestore con la nueva fecha
              await db.collection('notas').doc(noteId).update({ assignedDate: dateString });
              console.log(`Nota ${noteId} actualizada con fecha ${dateString}`);

              // Actualiza caches locales para reflejar el cambio inmediatamente
              if (notesDataCache[noteId]) {
                  notesDataCache[noteId].assignedDate = dateString;
              } else {
                  // Si la nota no estaba en caché (raro), la añadimos
                  notesDataCache[noteId] = { assignedDate: dateString };
              }
              // Quita la nota de la lista de la fecha anterior (si existía)
              if (oldDateStr && assignedDatesCache[oldDateStr]) {
                assignedDatesCache[oldDateStr] = assignedDatesCache[oldDateStr].filter(id => id !== noteId);
                if (assignedDatesCache[oldDateStr].length === 0) delete assignedDatesCache[oldDateStr];
              }
              // Añade la nota a la lista de la nueva fecha
              if (!assignedDatesCache[dateString]) assignedDatesCache[dateString] = [];
              if (!assignedDatesCache[dateString].includes(noteId)) assignedDatesCache[dateString].push(noteId);

              // Oculta la burbuja en la tarjeta de la nota (ya que ahora está asignada)
              const bubbleInCard = document.getElementById(`bubble-${noteId}`);
              if (bubbleInCard) bubbleInCard.style.display = 'none';

              // Regenera el calendario para mostrar la nueva burbuja
              generateCalendar(currentCalendarMonth, currentCalendarYear);

            } catch (err) {
              console.error(`Error asignando fecha a nota ${noteId}:`, err);
              alert("Error al asignar la fecha a la nota.");
            }
          }
        });
        datesG.appendChild(cell);
      }

      // Celdas vacías después del último día (para completar la cuadrícula)
      const totalCells = firstDayOfMonth + daysInMonth;
      const cellsNeeded = totalCells <= 35 ? 35 : 42; // Asegura 5 o 6 filas
      for (let i = totalCells; i < cellsNeeded; i++) {
        const e = document.createElement('div');
        e.className = 'calendar-date empty';
        datesG.appendChild(e);
      }

      calendarWidgetElem.appendChild(datesG);

      // Guarda el mes y año actual del calendario mostrado
      currentCalendarMonth = month;
      currentCalendarYear = year;
    } // --- Fin de generateCalendar ---

    // --- Funciones para Mostrar/Ocultar Calendario ---
    function showCalendar() {
      if (!calendarWidgetElem) return;
      clearTimeout(calendarTimeout); // Cancela timer de ocultar si existe
      if (calendarWidgetElem.style.display !== 'block') {
        const { month, year } = initCalendarDate(); // Obtiene mes/año inicial
        generateCalendar(month, year); // Genera el calendario
        calendarWidgetElem.style.display = 'block'; // Lo muestra
      }
    }

    function hideCalendar() {
      if (!calendarWidgetElem) return;
      // Oculta el calendario después de un breve retraso (para permitir mover el mouse)
      calendarTimeout = setTimeout(() => {
        calendarWidgetElem.style.display = 'none';
      }, 300); // 300ms de retraso
    }

    // Eventos para mostrar/ocultar calendario con hover
    if (calendarIconElem) {
      calendarIconElem.addEventListener('mouseenter', showCalendar);
      calendarIconElem.addEventListener('mouseleave', hideCalendar);
      // También permite abrir/cerrar con click (más amigable en móvil)
      calendarIconElem.addEventListener('click', () => {
          if (calendarWidgetElem && calendarWidgetElem.style.display === 'block') {
              hideCalendar();
          } else {
              showCalendar();
          }
      });
    }
    if (calendarWidgetElem) {
      // Mantiene el calendario visible si el mouse entra en él
      calendarWidgetElem.addEventListener('mouseenter', () => clearTimeout(calendarTimeout));
      calendarWidgetElem.addEventListener('mouseleave', hideCalendar);
    }

    // Función auxiliar para abrir calendario (usada en dragstart)
    function openCalendar() {
      showCalendar();
    }

    // --- Lógica Central de Autenticación y Carga de Datos ---
    auth.onAuthStateChanged(user => {
      if (user) {
        // --- USUARIO CONECTADO ---
        console.log('Usuario conectado:', user.email);
        // Actualiza la UI: oculta login, muestra info de usuario
        if (loginFormDiv) loginFormDiv.style.display = 'none';
        if (userInfoDiv) userInfoDiv.style.display = 'block';
        if (userEmailDisplay) userEmailDisplay.textContent = user.email;

        // Iniciar el listener de Firestore para las notas SI NO está ya activo
        if (!unsubscribeFirestore) {
            console.log("(Auth) Iniciando listener de Firestore para notas...");
            unsubscribeFirestore = db.collection('notas')
              // Opcional: Ordenar notas (ej. por fecha de creación descendente)
              // .orderBy('createdAt', 'desc')
              .onSnapshot((snapshot) => {
                // Verifica si grid existe aquí, crucial
                if (!grid) {
                  console.error("(Auth) GridStack no está listo dentro del listener onSnapshot.");
                  return;
                }
                console.log("(Auth) Datos de notas recibidos/actualizados.");
                let needsCalendarUpdate = false; // Flag para saber si recalcular calendario

                snapshot.docChanges().forEach((change) => {
                  const noteId = change.doc.id;
                  const notaData = change.doc.data();
                  console.log(`(Auth) Cambio: Tipo=${change.type}, ID=${noteId}`);

                  const widgetElement = displayedNotes.get(noteId); // Busca en nuestro Map

                  if (change.type === "added") {
                    if (!widgetElement) { // Solo añade si no existe ya en el Map
                      console.log(`(Auth) Añadiendo widget para ${noteId}`);
                      if (typeof mostrarNotaEnPantalla === 'function') {
                          const result = mostrarNotaEnPantalla(change.doc);
                          if (result) {
                            grid.addWidget(result.element, result.position);
                            notesDataCache[noteId] = notaData; // Actualiza cache de datos
                            displayedNotes.set(noteId, result.element); // Registra en el Map
                            if (notaData.assignedDate) needsCalendarUpdate = true;
                          }
                      } else { console.error("Función mostrarNotaEnPantalla no definida"); }
                    } else {
                      console.log(`(Auth) 'added' pero widget ${noteId} ya estaba en el Map. Verificando datos.`);
                      // Asegura que los datos estén sincronizados
                      widgetElement.docData = notaData;
                      notesDataCache[noteId] = notaData;
                      if (notaData.assignedDate !== (widgetElement.docData?.assignedDate)) {
                          needsCalendarUpdate = true;
                      }
                    }
                  } else if (change.type === "modified") {
                    console.log(`(Auth) Modificando widget para ${noteId}`);
                    if (widgetElement) {
                      const oldData = widgetElement.docData || {};
                      // --- Actualiza el contenido del widget existente ---
                      const noteContentElement = widgetElement.querySelector('.note-content');
                      const newText = notaData.url ? (notaData.texto || '') : (notaData.nota || '');
                      if (noteContentElement && newText !== (oldData.texto || oldData.nota || '')) {
                           console.log(`(Auth) - Actualizando texto para ${noteId}`);
                           if(typeof linkify === 'function') {
                               noteContentElement.innerHTML = linkify(newText);
                               Array.from(noteContentElement.getElementsByTagName('a')).forEach(link => {
                                    link.setAttribute('target', '_blank');
                                    link.setAttribute('rel', 'noopener noreferrer');
                               });
                           } else { noteContentElement.textContent = newText; }
                      }
                      if (notaData.url && notaData.url !== oldData.url) {
                           console.log(`(Auth) - Actualizando URL imagen para ${noteId}`);
                           const img = widgetElement.querySelector('.image-container img');
                           if (img) img.src = notaData.url;
                           else { // Si no había imagen y ahora sí, recrea? O añade?
                                const imageContainer = widgetElement.querySelector('.image-container');
                                if(imageContainer) { /* Lógica para añadir img si no existía */ }
                           }
                      }
                      // Actualiza burbuja calendario
                      const bubbleButton = widgetElement.querySelector(`#bubble-${noteId}`);
                      if (bubbleButton) {
                            const needsBubble = !notaData.assignedDate;
                            const isBubbleVisible = bubbleButton.style.display !== 'none';
                            if (needsBubble && !isBubbleVisible) {
                                console.log(`(Auth) - Mostrando burbuja para ${noteId}`);
                                bubbleButton.style.display = 'inline-block';
                            } else if (!needsBubble && isBubbleVisible) {
                                console.log(`(Auth) - Ocultando burbuja para ${noteId}`);
                                bubbleButton.style.display = 'none';
                            }
                      }
                      // --- Fin actualizar widget ---
                      if (notaData.assignedDate !== oldData.assignedDate) {
                         needsCalendarUpdate = true;
                      }
                      widgetElement.docData = notaData; // Actualiza datos guardados en el elemento
                      notesDataCache[noteId] = notaData; // Actualiza caché general
                    } else {
                      console.warn(`(Auth) Se recibió 'modified' para ${noteId}, pero widget no encontrado en Map.`);
                      // Si no está en el Map, quizás deberíamos añadirlo?
                      notesDataCache[noteId] = notaData; // Actualiza caché de datos
                      needsCalendarUpdate = true; // Asume que puede afectar calendario
                    }
                  } else if (change.type === "removed") {
                     console.log(`(Auth) Eliminando widget para ${noteId}`);
                     if (widgetElement) {
                        grid.removeWidget(widgetElement); // Elimina del grid
                        displayedNotes.delete(noteId); // Elimina del Map
                        if (notesDataCache[noteId]?.assignedDate) needsCalendarUpdate = true;
                        delete notesDataCache[noteId]; // Elimina de caché general
                        document.querySelectorAll(`.assigned-bubble[data-note='${noteId}']`).forEach(b => b.remove()); // Limpia calendario
                     } else {
                       console.warn(`(Auth) Se recibió 'removed' para ${noteId}, pero no encontrado en Map.`);
                       delete notesDataCache[noteId]; // Limpia caché por si acaso
                       document.querySelectorAll(`.assigned-bubble[data-note='${noteId}']`).forEach(b => b.remove());
                       needsCalendarUpdate = true;
                     }
                  }
                }); // Fin forEach docChanges

                // Actualiza calendario si es necesario Y está visible
                if (needsCalendarUpdate && typeof generateCalendar === 'function' && calendarWidgetElem && calendarWidgetElem.style.display === 'block') {
                  console.log("(Auth) Actualizando calendario (visible) porque needsCalendarUpdate es true.");
                  if (typeof fetchAllAssignedNotes === 'function') {
                      fetchAllAssignedNotes().then(() => {
                         generateCalendar(currentCalendarMonth, currentCalendarYear);
                      });
                  } else { console.error("Funcion fetchAllAssignedNotes no definida"); }
                } else if (needsCalendarUpdate && typeof fetchAllAssignedNotes === 'function') {
                  // Si no está visible, al menos recarga datos para la próxima vez que se abra
                  fetchAllAssignedNotes();
                }

            }, (error) => { // Manejo de error del listener onSnapshot
                console.error("(Auth) Error crítico escuchando Firestore:", error);
                alert("Error grave al obtener notas: " + error.message + ". Intenta recargar la página.");
                if (error.code === 'permission-denied') {
                    console.warn("Permiso denegado. Cerrando sesión.");
                    auth.signOut();
                }
                // Considera detener el listener si hay errores persistentes
                // if (unsubscribeFirestore) { unsubscribeFirestore(); unsubscribeFirestore = null; }
            }); // Fin onSnapshot
            console.log("(Auth) Listener de Firestore para notas ACTIVADO.");
        } // Fin if (!unsubscribeFirestore)

      } else {
        // --- USUARIO DESCONECTADO ---
        console.log('Nadie conectado. Limpiando estado...');
        // Actualiza UI: muestra login, oculta info user
        if (loginFormDiv) loginFormDiv.style.display = 'block';
        if (userInfoDiv) userInfoDiv.style.display = 'none';

        // Detener el listener de Firestore si está activo
        if (unsubscribeFirestore) {
          unsubscribeFirestore();
          unsubscribeFirestore = null; // Importante resetear
          console.log("Listener de notas DETENIDO.");
        }
        // Limpiar el grid y los caches
        if (grid) {
          grid.removeAll(true); // true para no animar y ser más rápido
          console.log("Grid limpiado.");
        }
        displayedNotes.clear();
        notesDataCache = {};
        assignedDatesCache = {};
        if (calendarWidgetElem) calendarWidgetElem.style.display = 'none'; // Oculta calendario

      } // Fin del else (usuario desconectado)
    }); // --- FIN BLOQUE onAuthStateChanged ---

    // --- Listeners para los Botones de Login/Logout ---
    // (Estos se definen UNA VEZ, fuera del onAuthStateChanged)
    if (loginButton && emailInput && passwordInput) {
      loginButton.addEventListener('click', () => {
        const email = emailInput.value;
        const password = passwordInput.value;
        if (!email || !password) {
          return alert('Ingresa correo y contraseña');
        }
        console.log("Intentando iniciar sesión para:", email);
        auth.signInWithEmailAndPassword(email, password)
          .then(userCredential => {
            // Éxito: onAuthStateChanged se encargará de actualizar la UI y cargar notas
            console.log('Login OK desde botón para:', userCredential.user.email);
          })
          .catch(error => {
            // Manejo de errores comunes de login
            console.error('Error Login Botón:', error.code, error.message);
            let mensajeError = 'Error al iniciar sesión.';
            if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                mensajeError = 'Correo o contraseña incorrectos.';
            } else if (error.code === 'auth/invalid-email') {
                mensajeError = 'El formato del correo no es válido.';
            }
            alert(mensajeError);
          });
      });
    } else {
      console.error("Error crítico: No se encontraron elementos para el formulario de login.");
    }

    if (logoutButton) {
      logoutButton.addEventListener('click', () => {
        console.log("Intentando cerrar sesión...");
        auth.signOut()
          .then(() => {
            // Éxito: onAuthStateChanged se encargará de limpiar
            console.log('Logout OK desde botón.');
          })
          .catch(error => {
            console.error('Error Logout Botón:', error);
            alert('Error al cerrar sesión: ' + error.message);
          });
      });
    } else {
      console.error("Error crítico: No se encontró el botón de logout.");
    }
    // --- FIN Código para los Botones ---
  </script>
</body>
</html>
```

**Cambios y Mejoras Realizadas (además de quitar líneas en blanco):**

1.  **Corrección Sintaxis `forEach`:** Arreglé definitivamente la línea del `forEach` dentro de `mostrarNotaEnPantalla` para que termine con `});`.
2.  **Corrección `try...catch` Gridstack:** Aseguré que el bloque `catch` esté presente después del `try` para `GridStack.init`.
3.  **Estructura `onAuthStateChanged`:** Confirmé que la estructura con el listener de Firestore (`onSnapshot`) dentro del `if(user)` y la limpieza (`unsubscribe`, `removeAll`) dentro del `else` sea la correcta y esté bien cerrada.
4.  **Listeners de Botones:** Confirmé que los `addEventListener` para los botones de login/logout estén fuera y después del `onAuthStateChanged`.
5.  **Manejo de Errores Mejorado:** Añadí `console.error` más descriptivos y algunos `alert` más específicos (ej. en login).
6.  **Limpieza de Caches:** Mejoré la lógica de limpieza de `notesDataCache` y `displayedNotes` al cerrar sesión y al eliminar notas.
7.  **Comentarios:** Añadí más comentarios para explicar mejor cada sección, especialmente el flujo de autenticación.
8.  **Pequeños Ajustes:** Hice ajustes menores como usar `removeAll(true)` para que la limpieza del grid sea más rápida al cerrar sesión.

Este código **debería funcionar** ahora sin errores de sintaxis y con la lógica de autenticación correctamente implementada. Pruébalo (idealmente en una ventana de incógnito primero para evitar caché) y dime si ahora sí puedes iniciar sesi
