<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Notas Oceánicas - Polaroid</title>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.9.0/firebase-firestore-compat.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@8.3.0/dist/gridstack.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/gridstack@8.3.0/dist/gridstack-all.js"></script>
  <style>
    /* ===================== Estilos Globales ===================== */
    html, body {
      margin: 0;
      padding: 0;
      height: 100vh;
      overflow: hidden; /* Evita scroll en el body */
      background: linear-gradient(to bottom, #a2dff7 0%, #a2dff7 40%, #03254c 100%);
      font-family: Arial, sans-serif;
    }
    .container {
      height: 100%;
      width: 100%;
      padding: 2cm; /* Manteniendo tu padding original */
      box-sizing: border-box;
      display: flex; /* Usar flexbox */
      flex-direction: column; /* Alinear contenido verticalmente */
      position: relative;
      overflow: hidden; /* Ocultar overflow del contenedor principal */
    }
    #notaDisplay {
      flex-grow: 1; /* Permitir que el área de notas crezca */
      width: 100%;
      overflow-y: auto; /* Permitir scroll DENTRO del área de notas */
      overflow-x: hidden;
      position: relative; /* Necesario para algunos cálculos de GridStack */
    }
    .grid-stack-placeholder { display: none !important; }

    /* --- Estilos GridStack Item --- */
    .grid-stack-item {
        transition: transform 0.4s cubic-bezier(0.25,1,0.5,1);
        /* IMPORTANTE: Se eliminó margin-bottom: 150px !important; para que GridStack controle el espacio */
        overflow: visible !important; /* Asegurar que el item tenga overflow visible por si el contenido crece */
    }
    /* Contenedor interno de Gridstack */
    .grid-stack-item-content {
        overflow: visible !important; /* Permitir que el contenido se desborde si es necesario */
        height: 100%; /* Ocupar toda la altura del item */
        display: flex; /* Usar flex para la tarjeta interna */
        flex-direction: column;
    }
    /* Ajuste para que el contenedor GridStack no interfiera con el margen inferior del último item */
    .grid-stack {
        padding-bottom: 1px; /* Pequeño padding para asegurar espacio visual al final */
    }

    /* ===================== Tarjetas de Nota ===================== */
    .card-wrapper, .text-card {
      background-color: #fff;
      border: 2px solid #0077a3;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      width: 240px; /* Ancho fijo de la tarjeta */
      display: flex;
      flex-direction: column;
      position: relative;
      height: 100%; /* Ocupar altura del contenedor .grid-stack-item-content */
      box-sizing: border-box;
    }
    .image-container {
      width: 100%; /* Ajustar al ancho de la tarjeta */
      height: 240px; /* Altura fija para la imagen */
      overflow: hidden;
      position: relative;
      flex-shrink: 0; /* Evitar que se encoja */
    }
    .image-container img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .note-content {
      padding: 10px;
      text-align: left;
      font-size: 16px;
      color: #333;
      min-height: 50px;
      box-sizing: border-box;
      word-wrap: break-word;
      overflow: hidden; /* Ocultar overflow del texto */
      flex-grow: 1; /* Permitir que crezca para llenar espacio */
      /* Considerar añadir overflow-y: auto si el texto es muy largo */
      /* max-height: 300px; */ /* Opcional: limitar altura máxima */
    }
    .note-content a { color: #0077a3; text-decoration: underline; }

    /* ===================== Área de Controles de la Nota ===================== */
    .menu-bar {
      background-color: #0288D1;
      padding: 5px 8px; /* Ajustar padding */
      display: flex;
      justify-content: space-between; /* Distribuir elementos */
      align-items: center;
      flex-shrink: 0;
      border-top: 1px solid #0077a3; /* Línea separadora opcional */
      border-bottom-left-radius: 6px; /* Redondear esquinas inferiores */
      border-bottom-right-radius: 6px;
      cursor: grab; /* Indicar que se puede arrastrar desde aquí */
    }
    .menu-icon {
      background: none;
      border: none;
      font-size: 20px;
      color: #fff;
      cursor: pointer;
      padding: 2px 4px; /* Área de clic un poco mayor */
    }
    .bubble-icon {
      color: #FFCD05;
      font-size: 22px;
      /* margin-right ya no es necesario con space-between */
    }
    /* Contenedor para botones de la derecha */
    .menu-actions {
        display: flex;
        gap: 4px;
    }

    /* ===================== Botón Principal para Agregar Nota/Imagen ===================== */
    #addNoteButton {
      position: absolute;
      bottom: 30px; /* Un poco más arriba */
      right: 30px;
      background-color: #006994;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 60px;
      height: 60px;
      font-size: 30px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0,0,0,0.3); /* Sombra más pronunciada */
      transition: background-color 0.3s ease, transform 0.3s ease;
      z-index: 1001;
    }
    #addNoteButton:hover {
      background-color: #005577;
      transform: scale(1.05);
    }

    /* ===================== Menú Emergente ===================== */
    #addNoteOptions {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0,0,0,0.85); /* Ligeramente más oscuro */
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.4);
      display: none;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      gap: 25px; /* Más espacio */
      padding: 25px;
      z-index: 1002;
    }
    #addNoteOptions .card {
      background-color: #2c2c2c; /* Fondo de tarjeta más oscuro */
      border: 1px solid #0077a3; /* Borde más sutil */
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      width: 180px; /* Ligeramente más estrechas */
    }
    #addNoteOptions .card:hover {
        transform: translateY(-5px) scale(1.03); /* Efecto hover */
        box-shadow: 0 6px 12px rgba(0, 119, 163, 0.5);
     }
    #addNoteOptions .card h2 { color: #36a2eb; margin-bottom: 10px; } /* Color de título */
    #addNoteOptions .card p { color: #ccc; font-size: 14px; } /* Color de texto */

    /* ===================== Submenú para Ingresar Datos ===================== */
    #inputArea {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #ffffff; /* Fondo blanco */
      padding: 25px 30px; /* Más padding */
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      display: none; /* Oculto por defecto */
      flex-direction: column;
      gap: 15px; /* Espacio entre elementos */
      width: 90%; /* Más ancho en móviles */
      max-width: 550px; /* Ancho máximo */
      z-index: 1002;
    }
    #inputArea label {
        font-weight: bold;
        color: #333;
        margin-bottom: 3px; /* Espacio debajo de la etiqueta */
        font-size: 14px;
    }
    #inputArea textarea,
    #inputArea input[type="text"] {
      padding: 12px; /* Más padding interno */
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
      width: 100%;
      box-sizing: border-box;
      line-height: 1.5;
      font-size: 16px; /* Tamaño de fuente */
    }
    #inputArea textarea { min-height: 80px; }
    #inputArea textarea#textNote { min-height: 120px; }

    #inputArea button {
      padding: 10px 20px; /* Más padding horizontal */
      background-color: #006994;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.1s ease;
      align-self: flex-end;
      margin-top: 10px;
      font-size: 16px;
      font-weight: bold;
    }
     #inputArea button:hover { background-color: #005577; }
     #inputArea button:active { transform: scale(0.98); } /* Efecto al presionar */
    .input-group { display: flex; flex-direction: column; gap: 5px; width: 100%;}


    /* ===================== Calendario ===================== */
    .calendar-icon {
      position: absolute;
      bottom: 30px; /* Alinear con botón Add */
      left: 30px;
      width: 45px; /* Ligeramente más grande */
      height: 45px;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      color: #333;
      font-size: 24px; /* Icono más grande */
      cursor: pointer;
      z-index: 1001;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .calendar-widget {
      position: absolute;
      bottom: 85px; /* Ajustar posición sobre el icono */
      left: 20px; /* Ajustar alineación */
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      padding: 15px; /* Más padding */
      display: none;
      z-index: 1001;
      width: 320px; /* Ancho ajustado */
      min-height: 300px; /* Altura ajustada */
    }
    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    .calendar-header button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 20px;
      color: #0077a3;
      padding: 5px 8px;
      border-radius: 4px;
      transition: background-color 0.2s ease;
    }
     .calendar-header button:hover:not(:disabled) { background-color: #e0f7fa; }
     .calendar-header button:disabled { color: #ccc; cursor: default; }
    .calendar-header span { font-weight: bold; color: #333; font-size: 18px; } /* Título más grande */

    .calendar-days-header,
    .calendar-dates-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      text-align: center;
      gap: 6px; /* Espacio entre celdas */
    }
    .calendar-days-header {
        margin-bottom: 10px;
        font-weight: bold;
        color: #555;
        padding-bottom: 8px;
        border-bottom: 1px solid #eee;
        font-size: 13px; /* Tamaño de días */
     }
    .calendar-day { padding: 3px; }

    .calendar-date {
      padding: 0; /* Quitar padding para controlar tamaño con width/height */
      border-radius: 50%;
      color: #333;
      border: 2px solid transparent; /* Borde para hover/today */
      cursor: pointer;
      position: relative;
      width: 36px; /* Tamaño fijo */
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto;
      line-height: 1;
      font-size: 14px; /* Tamaño número */
      transition: background-color 0.2s ease, border-color 0.2s ease;
    }
    .calendar-date.empty {
        background: none;
        cursor: default;
        opacity: 0;
     }
    .calendar-date:not(.empty):hover {
         background-color: #e0f7fa;
         border-color: #b3e5fc;
    }
    .calendar-date.today {
        border-color: #0077a3; /* Borde azul para hoy */
        font-weight: bold;
        color: #005577;
    }
    /* Drop target feedback */
    .calendar-date.drag-over {
        background-color: #a2dff7 !important; /* Color fuerte al arrastrar sobre */
        border-color: #0077a3 !important;
    }


    /* Indicador de la bolita asignada en el calendario */
    .assigned-bubble {
      color: #FFCD05; /* Amarillo */
      font-size: 11px; /* Tamaño ajustado */
      position: absolute;
      bottom: 3px; /* Posición */
      left: 50%;
      transform: translateX(-50%);
      line-height: 1;
      text-shadow: 0 0 1px rgba(0,0,0,0.5); /* Sombra para visibilidad */
      pointer-events: none; /* No interferir con clics en la fecha */
    }
    /* Permitir múltiples bolitas (simple apilado vertical) */
    .calendar-date .assigned-bubble + .assigned-bubble {
        bottom: -2px; /* Ajustar posición si hay más de una */
    }


    /* ===================== Capa para Cerrar Menús (Blur) ===================== */
    .blur-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.6); /* Más oscuro */
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      display: none;
      z-index: 1000;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="notaDisplay" class="grid-stack"></div>

    <button id="addNoteButton" title="Añadir nueva nota o imagen">+</button>

    <div id="addNoteOptions">
      <div class="card" id="addImageLinkOption" title="Añadir una nota con imagen desde un enlace web">
        <h2>🖼️ Imagen</h2>
        <p>Guardar link de imagen.</p>
      </div>
      <div class="card" id="addTextNoteOption" title="Añadir una nota de texto simple">
        <h2>📝 Nota</h2>
        <p>Subir nota de texto.</p>
      </div>
    </div>

    <div id="inputArea">
      <div id="imageLinkInputArea" style="display: none;">
        <div class="input-group">
          <label for="imageLink">Link de la imagen:</label>
          <input type="text" id="imageLink" placeholder="Pega aquí la URL de la imagen (ej: https://...)" />
        </div>
        <div class="input-group">
          <label for="imageNoteText">Texto adicional (opcional):</label>
          <textarea id="imageNoteText" placeholder="Escribe aquí una descripción o nota relacionada con la imagen..." rows="3"></textarea>
        </div>
        <button id="saveImageLink">Guardar Imagen</button>
      </div>
      <div id="textNoteInputArea" style="display: none;">
       <div class="input-group">
          <label for="textNote">Nota:</label>
          <textarea id="textNote" placeholder="Escribe tu nota aquí..." rows="5"></textarea>
        </div>
        <button id="saveTextNote">Guardar Nota</button>
      </div>
    </div>

    <div id="calendarIcon" class="calendar-icon" title="Mostrar/Ocultar Calendario">📅</div>
    <div id="calendarWidget" class="calendar-widget"></div>

    <div class="blur-background"></div>
  </div>

  <script>
    /****************** Utilidades y Configuración de Firebase ******************/

    // Función para transformar links de Google Drive a formato de imagen directa
    function transformDriveLink(url) {
        if (!url || !url.includes("drive.google.com")) return url; // Salir si no es link de Drive

        // Ya está en formato correcto?
        if (url.includes("/uc?export=view&id=")) return url;

        let fileId = null;
        // Patrones comunes de Google Drive
        const patterns = [
            /\/file\/d\/([a-zA-Z0-9_-]+)\//,         // /file/d/FILE_ID/...
            /[?&]id=([a-zA-Z0-9_-]+)(?:&|$)/,      // ...?id=FILE_ID... o ...&id=FILE_ID...
            /open\?id=([a-zA-Z0-9_-]+)(?:&|$)/,     // ...open?id=FILE_ID...
            /\/d\/([a-zA-Z0-9_-]+)\/(?:edit|view)/    // /d/FILE_ID/edit... o /d/FILE_ID/view...
        ];

        for (const regex of patterns) {
            const match = url.match(regex);
            if (match && match[1]) {
                fileId = match[1];
                break; // Encontramos el ID
            }
        }

        return fileId ? `https://drive.google.com/uc?export=view&id=${fileId}` : url; // Devuelve formato directo o URL original si no hay ID
    }

    // Función para convertir texto con URLs en HTML con enlaces clicables
    function linkify(text) {
      if (!text) return "";
      // Regex mejorado para evitar convertir URLs dentro de atributos href
      const urlRegex = /(?<!href=["'])(https?:\/\/[^\s<>"']+)/g;
      const replacedText = text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
      // Reemplazar saltos de línea por <br> para visualización HTML
      return replacedText.replace(/\n/g, '<br>');
    }

    // --- Configuración de Firebase ---
    // ¡¡¡ADVERTENCIA DE SEGURIDAD!!!
    // Exponer la API Key aquí es común pero REQUIERE que tengas
    // REGLAS DE SEGURIDAD EN FIRESTORE bien configuradas para
    // proteger tus datos contra accesos no autorizados.
    const firebaseConfig = {
      apiKey: "AIzaSyCHa373WgLLHsy8wZXK9zr_HVieQvlrhUs", // ¡Considera tus reglas de seguridad!
      authDomain: "oasis-b036d.firebaseapp.com",
      projectId: "oasis-b036d",
      storageBucket: "oasis-b036d.appspot.com",
      messagingSenderId: "141546637821",
      appId: "1:141546637821:web:0a861aeb13831774ed3194",
      measurementId: "G-HB2P17H5YL"
    };

    // Inicializar Firebase
    try {
        firebase.initializeApp(firebaseConfig);
    } catch (e) {
        console.error("Error inicializando Firebase:", e);
        alert("Error crítico: No se pudo inicializar la conexión a la base de datos.");
    }
    const db = firebase.firestore();

    /****************** Inicialización de GridStack ******************/
    let grid; // Declarar grid aquí para acceso global en el script
    try {
        grid = GridStack.init({
          margin: 75, // Espacio horizontal Y vertical (aprox 2cm) entre items
          cellHeight: 'auto', // Altura de celda basada en contenido
          disableResize: true, // Deshabilitar redimensión
          float: false, // Mantenido en false para filas predecibles y margen vertical
          animate: true, // Animar cambios
          alwaysShowResizeHandle: false,
          draggable: {
              handle: '.menu-bar', // Solo se puede arrastrar desde la barra de menú
              scroll: true, // Permitir scroll de la página mientras se arrastra
              appendTo: 'body' // Para evitar problemas de z-index al arrastrar
          }
        });
    } catch (e) {
        console.error("Error inicializando GridStack:", e);
        alert("Error al iniciar el área de notas. La página puede no funcionar correctamente.");
    }

    // --- Permitir scroll dentro del grid ---
    const gridContainer = document.getElementById('notaDisplay');
    if (gridContainer) {
        gridContainer.addEventListener('wheel', function(event) {
            // No prevenir scroll vertical por defecto
        }, { passive: true });
    }

    // --- Función para autoajustar altura de textareas ---
    function autoResizeTextarea(el) {
        if (!el) return;
        el.style.height = 'auto'; // Resetear altura
        // Añadir 2px extra puede ayudar a evitar scrollbar innecesario a veces
        el.style.height = (el.scrollHeight + 2) + 'px';
    }
    // Aplicar a los textareas del modal de input
    const textNoteInputElem = document.getElementById('textNote');
    const imageNoteTextElem = document.getElementById('imageNoteText');
    if (textNoteInputElem) textNoteInputElem.addEventListener('input', () => autoResizeTextarea(textNoteInputElem));
    if (imageNoteTextElem) imageNoteTextElem.addEventListener('input', () => autoResizeTextarea(imageNoteTextElem));


    /****************** Renderización de Notas, Edición y Eliminación ******************/

    // Cache local para referencia rápida (opcional pero usado aquí)
    const displayedNotes = new Map();

    // --- FUNCIÓN PARA MOSTRAR NOTA EN PANTALLA ---
    function mostrarNotaEnPantalla(doc) {
      const notaData = doc.data();
      const noteId = doc.id;

      // Crear el elemento contenedor para GridStack
      let gridItem = document.createElement('div');
      gridItem.classList.add('grid-stack-item');
      gridItem.setAttribute('data-note-id', noteId); // Para referencia

      // Crear el contenido interno que GridStack necesita
      const content = document.createElement('div');
      content.classList.add('grid-stack-item-content');

      let card; // Elemento de la tarjeta (imagen o texto)
      let noteContentElement; // Elemento específico para el texto de la nota

      // --- Tarjeta de Imagen ---
      if (notaData.url) {
          card = document.createElement('div');
          card.classList.add('card-wrapper');

          const imageContainer = document.createElement('div');
          imageContainer.classList.add('image-container');
          const img = document.createElement('img');
          img.src = transformDriveLink(notaData.url); // Usa la función para transformar link de Drive
          img.alt = notaData.texto || 'Imagen de la nota'; // Usar texto como alt
          img.loading = 'lazy'; // Carga diferida para mejorar rendimiento
          img.onerror = () => { // Manejo de error si la imagen no carga
              img.alt = 'Error al cargar imagen';
              // Muestra un mensaje de error dentro del contenedor de imagen
              imageContainer.innerHTML = `<div style="display:flex; align-items:center; justify-content:center; height:100%; background-color:#eee; color:red; text-align:center; padding:10px;">⚠️<br/>Error al<br/>cargar imagen</div>`;
          }
          imageContainer.appendChild(img);
          card.appendChild(imageContainer);

          // Añadir área de texto solo si existe texto asociado a la imagen
          if(notaData.texto) {
              noteContentElement = document.createElement('div');
              noteContentElement.classList.add('note-content');
              noteContentElement.innerHTML = linkify(notaData.texto); // Convertir links y saltos de línea
              card.appendChild(noteContentElement);
          }

      // --- Tarjeta de Texto ---
      } else if (notaData.nota) {
          card = document.createElement('div');
          card.classList.add('text-card'); // Clase específica para tarjeta de solo texto

          noteContentElement = document.createElement('div');
          noteContentElement.classList.add('note-content');
          noteContentElement.innerHTML = linkify(notaData.nota); // Convertir links y saltos de línea
          card.appendChild(noteContentElement);
      } else {
          // Si la nota no tiene ni URL ni texto, no la mostramos
          console.warn("Nota sin contenido visible (URL o Texto):", noteId);
          return null; // No añadir si no hay nada que mostrar
      }

      // Asegurar que los links en el contenido se abran en nueva pestaña
      if (noteContentElement) {
          Array.from(noteContentElement.getElementsByTagName('a')).forEach(link => {
              link.setAttribute('target', '_blank');
              link.setAttribute('rel', 'noopener noreferrer');
          });
      }

      // --- Barra de Menú (Arrastre, Bolita, Editar, Eliminar) ---
      const menuBar = document.createElement('div');
      menuBar.classList.add('menu-bar'); // También es el handle para arrastrar (ver GridStack init)

      // Botón Bolita (para asignar fecha en calendario)
      const bubbleButton = document.createElement('button');
      bubbleButton.classList.add('menu-icon', 'bubble-icon');
      bubbleButton.innerHTML = '●'; // Símbolo de la bolita
      bubbleButton.setAttribute('draggable', 'true'); // Hacerlo arrastrable
      bubbleButton.id = `bubble-${noteId}`;
      bubbleButton.title = "Arrastrar al calendario para asignar fecha";
      // Ocultar si ya tiene fecha asignada
      bubbleButton.style.display = notaData.assignedDate ? 'none' : 'inline-block';

      // Evento dragstart para la bolita
      bubbleButton.addEventListener('dragstart', (e) => {
          // Usar imagen fantasma transparente para mejor feedback visual
          var imgGhost = new Image();
          imgGhost.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
          e.dataTransfer.setDragImage(imgGhost, 0, 0);
          // Pasar el ID de la nota
          e.dataTransfer.setData("application/note-id", noteId);
          e.dataTransfer.effectAllowed = "move";
          openCalendar(); // Abrir calendario al empezar a arrastrar
      });
      // También abrir calendario al hacer clic (por si no se quiere arrastrar)
      bubbleButton.addEventListener('click', (e) => { e.stopPropagation(); openCalendar(); });

      // Contenedor para acciones (derecha)
      const menuActions = document.createElement('div');
      menuActions.classList.add('menu-actions');

      // Botón Editar
      const editButton = document.createElement('button');
      editButton.classList.add('menu-icon');
      editButton.innerHTML = '✎'; // Icono lápiz
      editButton.title = "Editar nota";
      editButton.onclick = (e) => {
          e.stopPropagation(); // Evitar que el evento llegue a la barra de menú (arrastre)
          if (typeof editNoteContent === 'function') {
              // Pasar elementos necesarios a la función de edición
              editNoteContent(card, noteId, notaData, menuActions, editButton, deleteButton);
          } else { console.error("Función editNoteContent no encontrada"); }
      };

      // Botón Eliminar (SIN CONFIRMACIÓN, como lo solicitaste)
      const deleteButton = document.createElement('button');
      deleteButton.classList.add('menu-icon');
      deleteButton.innerHTML = '✖'; // Icono 'X'
      deleteButton.title = "Eliminar nota";
      deleteButton.onclick = (e) => {
          e.stopPropagation();
          // Llamar a deleteNote directamente SIN confirmación
          if (typeof deleteNote === 'function') {
              deleteNote(noteId, gridItem); // Se elimina directamente
          } else {
              console.error("Función deleteNote no encontrada");
          }
      };

      // Añadir botones a sus contenedores
      menuActions.appendChild(editButton);
      menuActions.appendChild(deleteButton);
      menuBar.appendChild(bubbleButton); // Bolita a la izquierda
      menuBar.appendChild(menuActions); // Acciones a la derecha

      // Añadir barra de menú a la tarjeta y tarjeta al contenido de GridStack
      card.appendChild(menuBar);
      content.appendChild(card);
      gridItem.appendChild(content);

      // --- Posición inicial para GridStack ---
      const pos = {
          x: notaData.x, // Posición X guardada en Firestore
          y: notaData.y, // Posición Y guardada en Firestore
          w: notaData.w || 2, // Ancho (default 2 columnas si no está guardado)
          // h: se deja que 'auto' (cellHeight) lo calcule basado en contenido
          id: noteId, // ID único para que GridStack identifique el widget
          // Si no hay posición guardada, GridStack la asignará automáticamente
          autoPosition: (notaData.x === undefined || notaData.y === undefined)
      };

      // Guardar datos en el elemento para referencia futura (opcional)
      gridItem.docData = notaData;

      // Devolver el elemento y su posición para que onSnapshot lo añada al grid
      return { element: gridItem, position: pos };
    }

    // --- FUNCIÓN PARA EDITAR NOTA (In-place) ---
    function editNoteContent(card, noteId, notaData, menuActionsContainer, editButton, deleteButton) {
        const noteContentElement = card.querySelector('.note-content');
        // Si no hay área de texto (ej. imagen sin texto inicial), crear una
        let targetElement = noteContentElement;
        if (!targetElement) {
            targetElement = document.createElement('div');
            targetElement.classList.add('note-content');
            // Insertar ANTES de la barra de menú
            card.insertBefore(targetElement, card.querySelector('.menu-bar'));
        }

        // Determinar si es nota de imagen o texto para saber qué campo actualizar
        const isImageNote = !!notaData.url;
        const currentText = isImageNote ? (notaData.texto || '') : (notaData.nota || '');

        targetElement.innerHTML = ''; // Limpiar contenido actual para poner el textarea

        // Crear textarea para edición
        const editInput = document.createElement('textarea');
        editInput.value = currentText; // Poner texto actual
        // Estilos para que se integre bien
        editInput.style.width = '100%';
        editInput.style.minHeight = '80px';
        editInput.style.height = 'auto'; // Permitir auto-resize
        editInput.style.boxSizing = 'border-box';
        editInput.style.border = '1px dashed #ccc'; // Borde distintivo modo edición
        editInput.style.resize = 'vertical'; // Permitir redimensionar verticalmente
        targetElement.appendChild(editInput);
        autoResizeTextarea(editInput); // Ajustar altura inicial
        editInput.addEventListener('input', () => autoResizeTextarea(editInput)); // Ajustar al escribir
        editInput.focus(); // Poner el foco para empezar a escribir

        // Crear botón Guardar Edición
        const saveEditButton = document.createElement('button');
        saveEditButton.classList.add('menu-icon');
        saveEditButton.innerHTML = '💾'; // Icono disquete
        saveEditButton.title = "Guardar cambios";
        saveEditButton.onclick = (e) => {
            e.stopPropagation();
            const newText = editInput.value.trim(); // Quitar espacios extra
            // Preparar datos para actualizar en Firestore
            const updateData = isImageNote ? { texto: newText || null } : { nota: newText };
            // Guardar null si el campo queda vacío para consistencia

            // Deshabilitar botón mientras guarda y mostrar indicador
            saveEditButton.disabled = true;
            saveEditButton.innerHTML = '⏳'; // Icono reloj de arena

            db.collection('notas').doc(noteId).update(updateData)
              .then(() => {
                  console.log("Nota actualizada en Firestore.");
                  // No es necesario actualizar la UI aquí manualmente,
                  // onSnapshot lo hará. Solo restauramos los botones.
                  menuActionsContainer.replaceChild(editButton, saveEditButton); // Poner Editar de nuevo
                  menuActionsContainer.appendChild(deleteButton); // Re-añadir Eliminar
              })
              .catch((error) => {
                  console.error('Error al actualizar la nota:', error);
                  alert("Error al guardar los cambios.");
                  // En caso de error, restaurar botones y habilitar Guardar
                  saveEditButton.disabled = false;
                  saveEditButton.innerHTML = '💾';
                  menuActionsContainer.replaceChild(editButton, saveEditButton);
                  menuActionsContainer.appendChild(deleteButton);
              });
        };

        // Reemplazar botones Editar/Eliminar con el botón Guardar
        menuActionsContainer.innerHTML = ''; // Limpiar acciones actuales
        menuActionsContainer.appendChild(saveEditButton); // Añadir botón Guardar
    }

    // --- FUNCIÓN PARA ELIMINAR NOTA ---
    // (Versión actualizada sin removeWidget manual)
    function deleteNote(noteId, gridItem) { // Aunque gridItem ya no se usa aquí, se mantiene por si acaso
      console.log("Eliminando nota:", noteId);
      db.collection('notas').doc(noteId).delete()
        .then(() => {
            console.log(`Nota ${noteId} eliminada de Firestore.`);
            // La eliminación visual la hará onSnapshot al recibir la actualización.

            // Limpiar cache local si se usa
            displayedNotes.delete(noteId);
            // Quitar burbujas del calendario asociadas a esta nota
            document.querySelectorAll(`.assigned-bubble[data-note='${noteId}']`).forEach(b => b.remove());
            // Podrías también forzar una regeneración del calendario si estuviera visible
            // if (document.getElementById('calendarWidget').style.display === 'block') {
            //    generateCalendar(currentCalendarMonth, currentCalendarYear);
            // }
        })
        .catch((error) => {
            // Este catch es solo para el error de la operación delete() en Firestore
            console.error("Error al solicitar eliminación de la nota en Firestore: ", error);
            alert("Error al eliminar la nota.");
        });
    }


    /****************** Escucha de Cambios en Firestore (onSnapshot) ******************/

    if (db && typeof db.collection === 'function') { // Verificar que db está inicializado
        db.collection('notas')
          // .orderBy('createdAt', 'desc') // Opcional: Ordenar si se necesita
          .onSnapshot((snapshot) => {
              console.log("Snapshot recibido. Redibujando notas...");
              if (!grid) {
                  console.error("GridStack no está inicializado. No se pueden mostrar notas.");
                  return;
              }

              // Limpiar completamente el grid visual ANTES de añadir los nuevos
              grid.removeAll(false); // false para no disparar eventos por cada widget eliminado
              displayedNotes.clear(); // Limpiar el cache de referencia local

              // Recorrer los documentos del snapshot actual
              snapshot.forEach((doc) => {
                  const noteId = doc.id;
                  // Llama a la función que crea el HTML y obtiene posición
                  const result = mostrarNotaEnPantalla(doc);

                  if (result && result.element && result.position) { // Verificar que devuelve lo esperado
                      // Añadir el widget al grid con su posición
                      grid.addWidget(result.element, result.position);
                      // Guardar referencia en el cache local
                      displayedNotes.set(noteId, result.element);
                  }
              });
              console.log(`Notas redibujadas: ${displayedNotes.size}`);

              // Actualizar calendario después de redibujar todo (por si cambiaron fechas asignadas)
              if (currentCalendarMonth !== undefined && currentCalendarYear !== undefined) {
                   // Recargar cache de fechas asignadas y regenerar calendario
                   fetchAllAssignedNotes().then(() => {
                       generateCalendar(currentCalendarMonth, currentCalendarYear);
                   });
              } else {
                   // Solo recargar cache si el calendario no está visible/inicializado
                   fetchAllAssignedNotes();
              }

          }, (error) => {
              // Este error es si el listener onSnapshot falla catastróficamente
              console.error("Error crítico al obtener notas de Firestore:", error);
              alert("Error al cargar las notas. Por favor, revisa la consola (F12) y considera recargar la página.");
          });
    } else {
        console.error("Firestore (db) no está inicializado correctamente.");
        alert("Error: No se pudo conectar a la base de datos. Las notas no se cargarán.");
    }


    /****************** Manejo de la Interfaz para Agregar Notas ******************/
    const addNoteButtonElem = document.getElementById('addNoteButton');
    const addNoteOptionsElem = document.getElementById('addNoteOptions');
    const addImageLinkOptionElem = document.getElementById('addImageLinkOption');
    const addTextNoteOptionElem = document.getElementById('addTextNoteOption');
    const inputAreaElem = document.getElementById('inputArea');
    const imageLinkInputAreaElem = document.getElementById('imageLinkInputArea');
    const imageLinkInputElem = document.getElementById('imageLink');
    // const imageNoteTextElem = Ya declarada y configurada con autoResizeTextarea
    const saveImageLinkButtonElem = document.getElementById('saveImageLink');
    const textNoteInputAreaElem = document.getElementById('textNoteInputArea');
    // const textNoteInputElem = Ya declarada y configurada con autoResizeTextarea
    const saveTextNoteButtonElem = document.getElementById('saveTextNote');
    const blurBackgroundElem = document.querySelector('.blur-background');

    // Función central para ocultar todos los menús/modales y limpiar campos
    function hideMenus() {
      if(addNoteOptionsElem) addNoteOptionsElem.style.display = 'none';
      if(inputAreaElem) inputAreaElem.style.display = 'none';
      if(blurBackgroundElem) blurBackgroundElem.style.display = 'none';
      // Limpiar campos de entrada
      if(imageLinkInputElem) imageLinkInputElem.value = '';
      if(imageNoteTextElem) { imageNoteTextElem.value = ''; autoResizeTextarea(imageNoteTextElem); }
      if(textNoteInputElem) { textNoteInputElem.value = ''; autoResizeTextarea(textNoteInputElem); }
    }

    // Mostrar/ocultar menú de opciones (+ -> Imagen/Nota)
    if (addNoteButtonElem) {
        addNoteButtonElem.onclick = function (event) {
            event.stopPropagation(); // Evitar que el clic cierre inmediatamente si el blur está activo
            // Si el menú de opciones ya está visible, ocultarlo todo
            if (addNoteOptionsElem && addNoteOptionsElem.style.display === 'flex') {
                hideMenus();
            } else if (addNoteOptionsElem && blurBackgroundElem) {
                // Si no, asegurarse que todo esté oculto y luego mostrar opciones + blur
                hideMenus();
                addNoteOptionsElem.style.display = 'flex';
                blurBackgroundElem.style.display = 'block';
            }
        };
    }

    // Mostrar área de input para Imagen
    if (addImageLinkOptionElem) {
        addImageLinkOptionElem.onclick = function (event) {
            event.stopPropagation();
            if(addNoteOptionsElem) addNoteOptionsElem.style.display = 'none'; // Ocultar menú opciones
            if(imageLinkInputAreaElem) imageLinkInputAreaElem.style.display = 'block'; // Mostrar input imagen
            if(textNoteInputAreaElem) textNoteInputAreaElem.style.display = 'none'; // Ocultar input texto
            if(inputAreaElem) inputAreaElem.style.display = 'flex'; // Mostrar contenedor input
            if(blurBackgroundElem) blurBackgroundElem.style.display = 'block'; // Mantener blur
            if(imageLinkInputElem) imageLinkInputElem.focus(); // Poner foco en input link
        };
    }

    // Mostrar área de input para Nota de Texto
    if (addTextNoteOptionElem) {
        addTextNoteOptionElem.onclick = function (event) {
            event.stopPropagation();
            if(addNoteOptionsElem) addNoteOptionsElem.style.display = 'none'; // Ocultar menú opciones
            if(imageLinkInputAreaElem) imageLinkInputAreaElem.style.display = 'none'; // Ocultar input imagen
            if(textNoteInputAreaElem) textNoteInputAreaElem.style.display = 'block'; // Mostrar input texto
            if(inputAreaElem) inputAreaElem.style.display = 'flex'; // Mostrar contenedor input
            if(blurBackgroundElem) blurBackgroundElem.style.display = 'block'; // Mantener blur
            if(textNoteInputElem) textNoteInputElem.focus(); // Poner foco en textarea
        };
    }

    // Ocultar todo al hacer clic en el fondo borroso
    if (blurBackgroundElem) {
        blurBackgroundElem.onclick = hideMenus;
    }

    // --- Funciones para Guardar Notas en Firestore ---
    function guardarLinkDeImagen() {
      if (!imageLinkInputElem) return;
      let link = imageLinkInputElem.value.trim();
      const texto = imageNoteTextElem ? imageNoteTextElem.value.trim() : '';

      if (link) { // Solo guardar si hay un link
        link = transformDriveLink(link); // Aplicar transformación Drive
        // Deshabilitar botón mientras guarda
        if(saveImageLinkButtonElem) saveImageLinkButtonElem.disabled = true;
        db.collection('notas').add({
          url: link,
          texto: texto || null, // Guardar null si no hay texto adicional
          createdAt: firebase.firestore.FieldValue.serverTimestamp(), // Fecha de creación
          tipo: 'imagen' // Marcar tipo (opcional pero útil)
        })
          .then(() => { hideMenus(); }) // Ocultar menús al guardar con éxito
          .catch((error) => {
              console.error('Error al guardar el link de imagen: ', error);
              alert("Error al guardar la imagen.");
          })
          .finally(() => {
              // Rehabilitar botón, haya éxito o error
              if(saveImageLinkButtonElem) saveImageLinkButtonElem.disabled = false;
          });
      } else {
          alert("Por favor, introduce un link para la imagen.");
          imageLinkInputElem.focus();
      }
    }

    function guardarNotaTexto() {
      if (!textNoteInputElem) return;
      const nota = textNoteInputElem.value.trim();

      if (nota) { // Solo guardar si hay texto
          // Deshabilitar botón mientras guarda
          if(saveTextNoteButtonElem) saveTextNoteButtonElem.disabled = true;
        db.collection('notas').add({
            nota: nota,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            tipo: 'texto'
        })
          .then(() => { hideMenus(); })
          .catch((error) => {
              console.error('Error al guardar la nota de texto: ', error);
              alert("Error al guardar la nota.");
           })
           .finally(() => {
              // Rehabilitar botón
              if(saveTextNoteButtonElem) saveTextNoteButtonElem.disabled = false;
           });
      } else {
          alert("Por favor, escribe algo en la nota.");
          textNoteInputElem.focus();
      }
    }

    // Asignar funciones a los botones de guardar
    if(saveImageLinkButtonElem) saveImageLinkButtonElem.onclick = guardarLinkDeImagen;
    if(saveTextNoteButtonElem) saveTextNoteButtonElem.onclick = guardarNotaTexto;

    // --- Guardar posición al mover una nota ---
    if (grid) {
        grid.on('dragstop', function (event, el) {
            // 'el' es el elemento DOM que se movió
            const node = el.gridstackNode; // Obtener info del nodo de GridStack
            const noteId = el.getAttribute('data-note-id'); // Obtener ID de la nota

            if (noteId && node) {
                // Usar un pequeño timeout puede ayudar a asegurar que la posición final esté calculada
                setTimeout(() => {
                    const currentNode = grid.engine.nodes.get(el); // Obtener nodo actualizado
                    if(currentNode){
                         // console.log(`Guardando posición para ${noteId}: x=${currentNode.x}, y=${currentNode.y}`);
                         db.collection('notas').doc(noteId).update({
                             x: currentNode.x, // Guardar nueva posición X
                             y: currentNode.y  // Guardar nueva posición Y
                         }).catch(error => console.error("Error guardando posición:", error));
                    }
                }, 50); // Reducido el timeout, probar si 50ms es suficiente
            }
        });
    }


    /****************** Calendario y Asignación de la Bolita ******************/
    let currentCalendarMonth, currentCalendarYear; // Guardar mes/año visible
    let assignedDatesCache = {}; // Cache { 'D/M/YYYY': [noteId1, noteId2] }
    let notesDataCache = {}; // Cache { noteId: { assignedDate: '...', ...otros datos... } }

    // Función para obtener fecha/hora actual en Chile/Santiago
    function getChileDate() {
        try {
            // Intentar usar Intl con timezone
            const options = { timeZone: 'America/Santiago', year: 'numeric', month: 'numeric', day: 'numeric', hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: false };
            const formatter = new Intl.DateTimeFormat('en-CA', options); // Formato YYYY-MM-DD
            const parts = formatter.formatToParts(new Date());
            const dateMap = {};
            parts.forEach(({ type, value }) => dateMap[type] = parseInt(value, 10));
            // Crear fecha UTC a partir de partes para evitar doble conversión de zona horaria
            return new Date(Date.UTC(dateMap.year, dateMap.month - 1, dateMap.day, dateMap.hour, dateMap.minute, dateMap.second));
        } catch (e) {
            // Si falla (navegador viejo?), usar hora local del cliente como fallback
            console.warn("Intl.DateTimeFormat con TimeZone no soportado o falló, usando hora local.", e);
            return new Date();
        }
    }

    // Determina mes/año inicial para el calendario (mínimo Dic 2024)
    function initCalendarDate() {
        let today = getChileDate();
        let year = today.getFullYear();
        let month = today.getMonth(); // 0 = Enero, 11 = Diciembre
        const minYear = 2024;
        const minMonth = 11; // Diciembre (índice 11)
        // Si la fecha actual es anterior a Dic 2024, empezar en Dic 2024
        if (year < minYear || (year === minYear && month < minMonth)) {
            return { month: minMonth, year: minYear };
        }
        // Si no, empezar en el mes y año actual
        return { month, year };
    }

    // Obtener nombre del mes en español
    function getMonthName(monthIndex) {
        const months = ['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'];
        return months[monthIndex % 12] || '';
    }

    // Carga (o recarga) el cache de notas con fechas asignadas desde Firestore
    async function fetchAllAssignedNotes() {
        assignedDatesCache = {}; // Limpiar cache de fechas
        notesDataCache = {}; // Limpiar cache de datos de notas
        try {
            // Obtener todas las notas que tengan el campo 'assignedDate'
            const snapshot = await db.collection('notas').where('assignedDate', '!=', null).get();
            snapshot.forEach(doc => {
                const data = doc.data();
                const noteId = doc.id;
                notesDataCache[noteId] = data; // Guardar datos de la nota
                const dateStr = data.assignedDate; // Formato 'D/M/YYYY'
                if (dateStr) {
                    // Añadir al cache de fechas
                    if (!assignedDatesCache[dateStr]) assignedDatesCache[dateStr] = [];
                    // Evitar duplicados si hubiera inconsistencias
                    if (!assignedDatesCache[dateStr].includes(noteId)) {
                        assignedDatesCache[dateStr].push(noteId);
                    }
                }
            });
            // console.log("Cache de fechas asignadas actualizado:", assignedDatesCache);
        } catch (error) {
            console.error("Error fetching assigned notes:", error);
            // Podría mostrar un error al usuario si la carga del calendario es crítica
        }
    }

    // Genera el HTML del calendario para un mes y año dados
    async function generateCalendar(month, year) {
        // Si el cache está vacío, cargarlo primero
        if (Object.keys(notesDataCache).length === 0 && Object.keys(assignedDatesCache).length === 0) {
           await fetchAllAssignedNotes();
        }

        const calendarDiv = document.getElementById('calendarWidget');
        if (!calendarDiv) return; // Salir si el elemento no existe
        calendarDiv.innerHTML = ''; // Limpiar calendario anterior
        const today = getChileDate(); // Para marcar el día actual

        // --- Cabecera del Calendario (Mes, Año, Botones) ---
        const header = document.createElement('div'); header.className = 'calendar-header';
        const prevBtn = document.createElement('button'); prevBtn.innerHTML = '&lt;'; // Flecha izquierda
        const minYear = 2024; const minMonth = 11; // Diciembre 2024 como mínimo
        // Deshabilitar botón 'anterior' si estamos en Dic 2024
        if (year === minYear && month === minMonth) {
          prevBtn.disabled = true;
        } else {
          // Calcular mes/año anterior al hacer clic
          prevBtn.onclick = () => generateCalendar(month === 0 ? 11 : month - 1, month === 0 ? year - 1 : year);
        }
        const nextBtn = document.createElement('button'); nextBtn.innerHTML = '&gt;'; // Flecha derecha
        // Calcular mes/año siguiente al hacer clic
        nextBtn.onclick = () => generateCalendar(month === 11 ? 0 : month + 1, month === 11 ? year + 1 : year);
        const title = document.createElement('span'); title.textContent = `${getMonthName(month)} ${year}`;
        header.appendChild(prevBtn); header.appendChild(title); header.appendChild(nextBtn);
        calendarDiv.appendChild(header);

        // --- Cabecera de los días de la semana (Do, Lu, Ma...) ---
        const daysHeader = document.createElement('div'); daysHeader.className = 'calendar-days-header';
        ['Do','Lu','Ma','Mi','Ju','Vi','Sá'].forEach(day => {
           const d = document.createElement('div');
           d.className = 'calendar-day'; d.textContent = day;
           daysHeader.appendChild(d);
         });
        calendarDiv.appendChild(daysHeader);

        // --- Grid de las fechas del mes ---
        const datesGrid = document.createElement('div'); datesGrid.className = 'calendar-dates-grid';
        // Calcular primer día de la semana del mes (0=Domingo, 1=Lunes...)
        const firstDayOfMonth = new Date(year, month, 1).getDay();
        // Calcular número de días en el mes
        const daysInMonth = new Date(year, month + 1, 0).getDate();

        // Añadir celdas vacías al inicio para alinear con el día de la semana
        for (let i = 0; i < firstDayOfMonth; i++) {
           const e = document.createElement('div'); e.className = 'calendar-date empty';
           datesGrid.appendChild(e);
         }

        // Añadir celdas para cada día del mes
        for (let date = 1; date <= daysInMonth; date++) {
            const dateCell = document.createElement('div'); dateCell.className = 'calendar-date';
            dateCell.textContent = date; // Número del día
            const dateStr = `${date}/${month + 1}/${year}`; // Formato 'D/M/YYYY' para el cache

            // Marcar el día de hoy
            if (date === today.getDate() && month === today.getMonth() && year === today.getFullYear()) {
               dateCell.classList.add('today');
            }

            // Añadir bolitas si hay notas asignadas a esta fecha (según cache)
            if (assignedDatesCache[dateStr]) {
                assignedDatesCache[dateStr].forEach(noteId => {
                    const b = document.createElement("span");
                    b.className = "assigned-bubble";
                    b.setAttribute("data-note", noteId); // Guardar ID de nota por si acaso
                    b.textContent = "●"; // Símbolo de bolita
                    dateCell.appendChild(b);
                });
            }

            // --- Eventos Drag & Drop para la celda de fecha ---
            // dragover: Necesario para indicar que es un destino válido
            dateCell.addEventListener('dragover', (e) => {
                e.preventDefault(); // Permitir soltar
                e.dataTransfer.dropEffect = "move"; // Indicar visualmente que se moverá
                dateCell.classList.add('drag-over'); // Añadir clase para feedback visual
            });
            // dragleave: Quitar feedback visual si el cursor sale
            dateCell.addEventListener('dragleave', (e) => {
                dateCell.classList.remove('drag-over');
            });
            // drop: Acción al soltar la bolita sobre la fecha
            dateCell.addEventListener('drop', async (e) => {
                e.preventDefault(); // Evitar comportamiento por defecto
                dateCell.classList.remove('drag-over'); // Quitar feedback visual
                const noteId = e.dataTransfer.getData("application/note-id"); // Obtener ID de la nota

                if (noteId) {
                    const oldDateStr = notesDataCache[noteId]?.assignedDate; // Fecha anterior (si existía)

                    try {
                        // Actualizar en Firestore
                        await db.collection('notas').doc(noteId).update({ assignedDate: dateStr });

                        // --- Actualizar Caches Locales INMEDIATAMENTE ---
                        // Actualizar cache de datos de la nota
                        if(notesDataCache[noteId]) {
                           notesDataCache[noteId].assignedDate = dateStr;
                        } else {
                           // Si la nota no estaba en cache (raro), añadirla
                           notesDataCache[noteId] = { assignedDate: dateStr };
                        }
                        // Quitar del cache de la fecha anterior (si existía)
                        if (oldDateStr && assignedDatesCache[oldDateStr]) {
                            assignedDatesCache[oldDateStr] = assignedDatesCache[oldDateStr].filter(id => id !== noteId);
                            // Si la fecha anterior queda vacía, eliminarla del cache
                            if (assignedDatesCache[oldDateStr].length === 0) {
                               delete assignedDatesCache[oldDateStr];
                            }
                        }
                        // Añadir al cache de la nueva fecha
                        if (!assignedDatesCache[dateStr]) assignedDatesCache[dateStr] = [];
                        if (!assignedDatesCache[dateStr].includes(noteId)) {
                           assignedDatesCache[dateStr].push(noteId);
                        }

                        // --- Actualizar UI (Ocultar bolita en tarjeta y regenerar calendario) ---
                        const bubbleInCard = document.getElementById(`bubble-${noteId}`);
                        if (bubbleInCard) bubbleInCard.style.display = 'none'; // Ocultar bolita en la tarjeta

                        // Regenerar el calendario para mostrar la bolita en la nueva fecha
                        generateCalendar(currentCalendarMonth, currentCalendarYear);

                    } catch (error) {
                        console.error(`Error al asignar fecha a nota ${noteId}:`, error);
                        alert("Error al asignar la fecha.");
                        // No se revierte el cache aquí, podría causar inconsistencia.
                        // onSnapshot eventualmente corregirá la UI si la BD no se actualizó.
                    }
                }
            });
            datesGrid.appendChild(dateCell);
        }

        // Añadir celdas vacías al final para completar la cuadrícula (usualmente 35 o 42 celdas total)
        const totalCells = firstDayOfMonth + daysInMonth;
        const cellsNeeded = totalCells <= 35 ? 35 : 42; // Apuntar a 5 o 6 filas
        for (let i = totalCells; i < cellsNeeded; i++) {
           const e = document.createElement('div'); e.className = 'calendar-date empty';
           datesGrid.appendChild(e);
         }

        calendarDiv.appendChild(datesGrid); // Añadir grid de fechas al widget

        // Guardar mes y año actual para referencia
        currentCalendarMonth = month;
        currentCalendarYear = year;
    }

    // --- Lógica para mostrar/ocultar calendario con hover y timeout ---
    const calendarIconElem = document.getElementById('calendarIcon');
    const calendarWidgetElem = document.getElementById('calendarWidget');
    let calendarTimeout; // Variable para el timeout

    // Muestra el calendario (si no está visible) y cancela el timeout de ocultar
    function showCalendar() {
        if (!calendarWidgetElem) return;
        clearTimeout(calendarTimeout); // Cancelar cualquier timeout pendiente para ocultar
        // Si no está visible, generar y mostrar
        if (calendarWidgetElem.style.display !== 'block') {
            const { month, year } = initCalendarDate(); // Obtener mes/año inicial
            generateCalendar(month, year); // Generar HTML del calendario
            calendarWidgetElem.style.display = 'block'; // Mostrarlo
        }
    }
    // Inicia un timeout para ocultar el calendario (se cancela si se vuelve a entrar)
    function hideCalendar() {
      if (!calendarWidgetElem) return;
      calendarTimeout = setTimeout(() => {
          calendarWidgetElem.style.display = 'none'; // Ocultar después de 300ms
      }, 300);
    }

    // Event listeners para icono y widget
    if (calendarIconElem) {
        calendarIconElem.addEventListener('mouseenter', showCalendar); // Mostrar al entrar al icono
        calendarIconElem.addEventListener('mouseleave', hideCalendar); // Iniciar ocultación al salir del icono
    }
    if (calendarWidgetElem) {
        // Cancelar ocultación si el ratón entra al propio widget
        calendarWidgetElem.addEventListener('mouseenter', () => clearTimeout(calendarTimeout));
        // Iniciar ocultación al salir del widget
        calendarWidgetElem.addEventListener('mouseleave', hideCalendar);
    }
    // Función para abrir el calendario programáticamente (usada en dragstart de bolita)
    function openCalendar() { showCalendar(); }


    /****************** Otros Event Listeners y Setup Inicial ******************/

    // Evitar que clics dentro de los menús/modales los cierren (propagación)
    if (addNoteOptionsElem) addNoteOptionsElem.addEventListener('click', (e) => e.stopPropagation());
    if (inputAreaElem) inputAreaElem.addEventListener('click', (e) => e.stopPropagation());

    // Cargar el cache inicial de notas asignadas al cargar la página
    fetchAllAssignedNotes();

    // --- Fin del Script ---
  </script>
</body>
</html>
